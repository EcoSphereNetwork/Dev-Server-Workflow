{
  "name": "LLM-Cost-Analyzer",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "analyze-costs",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 300],
      "id": "cost-analyzer-webhook"
    },
    {
      "parameters": {
        "functionCode": "// Kostendatenbank für verschiedene LLM-Modelle\nconst llmCostDb = {\n  // Cloud Modelle\n  \"claude-3-5-sonnet\": {\n    \"type\": \"cloud\",\n    \"inputCost\": 3.0, // pro 1M Token\n    \"outputCost\": 15.0, // pro 1M Token\n    \"maxContext\": 200000,\n    \"provider\": \"anthropic\"\n  },\n  \"claude-3-opus\": {\n    \"type\": \"cloud\",\n    \"inputCost\": 15.0,\n    \"outputCost\": 75.0,\n    \"maxContext\": 200000,\n    \"provider\": \"anthropic\"\n  },\n  \"gpt-4o\": {\n    \"type\": \"cloud\",\n    \"inputCost\": 10.0,\n    \"outputCost\": 30.0,\n    \"maxContext\": 128000,\n    \"provider\": \"openai\"\n  },\n  \"gpt-4o-mini\": {\n    \"type\": \"cloud\",\n    \"inputCost\": 5.0,\n    \"outputCost\": 15.0,\n    \"maxContext\": 128000,\n    \"provider\": \"openai\"\n  },\n  \n  // Lokale Modelle\n  \"local-1.5b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 1500,  // Anschaffungskosten in Euro\n    \"powerConsumptionW\": 150,  // Watt\n    \"inferenceSpeed\": 100,  // Tokens/Sekunde\n    \"maxContext\": 4096,\n    \"maintenanceCostPerMonth\": 50\n  },\n  \"local-3b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 2000,\n    \"powerConsumptionW\": 200,\n    \"inferenceSpeed\": 70,\n    \"maxContext\": 8192,\n    \"maintenanceCostPerMonth\": 75\n  },\n  \"local-7b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 2500,\n    \"powerConsumptionW\": 300,\n    \"inferenceSpeed\": 50,\n    \"maxContext\": 8192,\n    \"maintenanceCostPerMonth\": 100\n  },\n  \"local-13b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 3000,\n    \"powerConsumptionW\": 400,\n    \"inferenceSpeed\": 30,\n    \"maxContext\": 16384,\n    \"maintenanceCostPerMonth\": 150\n  },\n  \"local-34b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 8000,\n    \"powerConsumptionW\": 800,\n    \"inferenceSpeed\": 15,\n    \"maxContext\": 32768,\n    \"maintenanceCostPerMonth\": 300\n  },\n  \"local-70b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 20000,\n    \"powerConsumptionW\": 1200,\n    \"inferenceSpeed\": 8,\n    \"maxContext\": 65536,\n    \"maintenanceCostPerMonth\": 500\n  }\n};\n\n// Kostenkalkulation für Cloud-Modelle\nfunction calculateCloudModelCost(model, inputTokens, outputTokens) {\n  const modelInfo = llmCostDb[model];\n  if (!modelInfo || modelInfo.type !== 'cloud') {\n    throw new Error(`Ungültiges Cloud-Modell: ${model}`);\n  }\n  \n  const inputCost = (inputTokens / 1000000) * modelInfo.inputCost;\n  const outputCost = (outputTokens / 1000000) * modelInfo.outputCost;\n  \n  return {\n    inputCost,\n    outputCost,\n    totalCost: inputCost + outputCost,\n    provider: modelInfo.provider,\n    maxContext: modelInfo.maxContext\n  };\n}\n\n// Kostenkalkulation für lokale Modelle\nfunction calculateLocalModelCost(model, inputTokens, outputTokens, energyPricePerKWh, amortizationMonths) {\n  const modelInfo = llmCostDb[model];\n  if (!modelInfo || modelInfo.type !== 'local') {\n    throw new Error(`Ungültiges lokales Modell: ${model}`);\n  }\n  \n  // Standardwerte, falls nicht angegeben\n  energyPricePerKWh = energyPricePerKWh || 0.30;  // 30 Cent pro kWh\n  amortizationMonths = amortizationMonths || 36;  // 3 Jahre Abschreibung\n  \n  // Gesamte Tokenanzahl\n  const totalTokens = inputTokens + outputTokens;\n  \n  // Berechnete Verarbeitungszeit in Stunden\n  const processingTimeHours = totalTokens / (modelInfo.inferenceSpeed * 3600);\n  \n  // Energiekosten\n  const energyConsumptionKWh = (modelInfo.powerConsumptionW / 1000) * processingTimeHours;\n  const energyCost = energyConsumptionKWh * energyPricePerKWh;\n  \n  // Abschreibungskosten pro Token\n  const hardwareCostPerMonth = modelInfo.hardwareCost / amortizationMonths;\n  const totalMonthlyTokens = modelInfo.inferenceSpeed * 3600 * 24 * 30 * 0.2;  // Annahme: 20% Auslastung\n  const hardwareCostPerToken = hardwareCostPerMonth / totalMonthlyTokens;\n  const hardwareCost = totalTokens * hardwareCostPerToken;\n  \n  // Wartungskosten\n  const maintenanceCostPerToken = modelInfo.maintenanceCostPerMonth / totalMonthlyTokens;\n  const maintenanceCost = totalTokens * maintenanceCostPerToken;\n  \n  return {\n    energyCost,\n    hardwareCost,\n    maintenanceCost,\n    totalCost: energyCost + hardwareCost + maintenanceCost,\n    processingTimeHours,\n    maxContext: modelInfo.maxContext\n  };\n}\n\n// Vergleichsfunktion für verschiedene Modelle\nfunction compareModels(taskData) {\n  const {\n    models,\n    inputTokens,\n    outputTokens,\n    energyPricePerKWh,\n    amortizationMonths,\n    minRequiredContext\n  } = taskData;\n  \n  const comparison = {};\n  \n  // Prüfe, ob die minimale Kontextlänge angegeben wurde\n  const contextRequirement = minRequiredContext || 0;\n  \n  for (const model of models) {\n    try {\n      const modelInfo = llmCostDb[model];\n      \n      // Überspringe Modelle, die nicht den Kontextanforderungen entsprechen\n      if (modelInfo.maxContext < contextRequirement) {\n        comparison[model] = {\n          error: `Modell unterstützt nicht die erforderliche Kontextlänge von ${contextRequirement} Tokens`,\n          maxContext: modelInfo.maxContext\n        };\n        continue;\n      }\n      \n      if (modelInfo.type === 'cloud') {\n        comparison[model] = calculateCloudModelCost(model, inputTokens, outputTokens);\n      } else {\n        comparison[model] = calculateLocalModelCost(\n          model, \n          inputTokens, \n          outputTokens, \n          energyPricePerKWh, \n          amortizationMonths\n        );\n      }\n    } catch (error) {\n      comparison[model] = { error: error.message };\n    }\n  }\n  \n  return comparison;\n}\n\n// Kosten-Projektionsfunktion\nfunction projectCosts(projectionData) {\n  const {\n    models,\n    monthlyRequests,\n    avgInputTokensPerRequest,\n    avgOutputTokensPerRequest,\n    growthRatePerMonth,\n    projectionMonths,\n    energyPricePerKWh,\n    amortizationMonths\n  } = projectionData;\n  \n  const projections = {};\n  \n  for (const model of models) {\n    try {\n      const modelInfo = llmCostDb[model];\n      const monthlyProjection = [];\n      let currentRequests = monthlyRequests;\n      \n      for (let month = 1; month <= projectionMonths; month++) {\n        const monthlyInputTokens = currentRequests * avgInputTokensPerRequest;\n        const monthlyOutputTokens = currentRequests * avgOutputTokensPerRequest;\n        \n        let monthlyCost;\n        if (modelInfo.type === 'cloud') {\n          const costInfo = calculateCloudModelCost(model, monthlyInputTokens, monthlyOutputTokens);\n          monthlyCost = costInfo.totalCost;\n        } else {\n          // Für lokale Modelle: Abschreibung + Wartung als feste Kosten\n          const fixedMonthlyCost = modelInfo.hardwareCost / amortizationMonths + modelInfo.maintenanceCostPerMonth;\n          \n          // Energiekosten basierend auf der Nutzung\n          const totalTokens = monthlyInputTokens + monthlyOutputTokens;\n          const processingTimeHours = totalTokens / (modelInfo.inferenceSpeed * 3600);\n          const energyConsumptionKWh = (modelInfo.powerConsumptionW / 1000) * processingTimeHours;\n          const energyCost = energyConsumptionKWh * energyPricePerKWh;\n          \n          monthlyCost = fixedMonthlyCost + energyCost;\n        }\n        \n        monthlyProjection.push({\n          month,\n          requests: currentRequests,\n          inputTokens: monthlyInputTokens,\n          outputTokens: monthlyOutputTokens,\n          cost: monthlyCost\n        });\n        \n        // Anfragen für den nächsten Monat anpassen (Wachstumsrate)\n        currentRequests = currentRequests * (1 + (growthRatePerMonth / 100));\n      }\n      \n      projections[model] = monthlyProjection;\n    } catch (error) {\n      projections[model] = { error: error.message };\n    }\n  }\n  \n  return projections;\n}\n\n// Optimaler Modellmix-Finder\nfunction findOptimalModelMix(mixData) {\n  const {\n    availableModels,\n    taskCategories,\n    monthlyRequests,\n    energyPricePerKWh,\n    amortizationMonths\n  } = mixData;\n  \n  // Stelle sicher, dass nur gültige Modelle verwendet werden\n  const validModels = availableModels.filter(model => llmCostDb[model]);\n  \n  // Berechne die Gesamtkosten für jeden Task-Typ mit jedem Modell\n  const taskModelCosts = {};\n  \n  for (const category of Object.keys(taskCategories)) {\n    const taskInfo = taskCategories[category];\n    taskModelCosts[category] = {};\n    \n    for (const model of validModels) {\n      try {\n        const modelInfo = llmCostDb[model];\n        \n        // Überprüfe, ob das Modell den Kontextanforderungen entspricht\n        if (modelInfo.maxContext < (taskInfo.contextRequirement || 0)) {\n          continue;\n        }\n        \n        const monthlyInputTokens = monthlyRequests * (taskInfo.percentage / 100) * taskInfo.avgInputTokens;\n        const monthlyOutputTokens = monthlyRequests * (taskInfo.percentage / 100) * taskInfo.avgOutputTokens;\n        \n        let cost;\n        if (modelInfo.type === 'cloud') {\n          const costInfo = calculateCloudModelCost(model, monthlyInputTokens, monthlyOutputTokens);\n          cost = costInfo.totalCost;\n        } else {\n          const costInfo = calculateLocalModelCost(\n            model, \n            monthlyInputTokens, \n            monthlyOutputTokens, \n            energyPricePerKWh, \n            amortizationMonths\n          );\n          cost = costInfo.totalCost;\n        }\n        \n        taskModelCosts[category][model] = {\n          cost,\n          qualityScore: taskInfo.qualityRequirement <= modelInfo.qualityScore ? 1 : 0.5 // Einfaches Qualitätsmodell\n        };\n      } catch (error) {\n        // Ignoriere Modelle mit Fehlern\n      }\n    }\n  }\n  \n  // Einfacher Greedy-Algorithmus zur Findung des optimalen Mixes\n  const optimalMix = {};\n  let totalCost = 0;\n  \n  for (const category of Object.keys(taskCategories)) {\n    // Finde das kostengünstigste Modell mit ausreichender Qualität\n    let bestModel = null;\n    let lowestCost = Infinity;\n    \n    for (const model in taskModelCosts[category]) {\n      const { cost, qualityScore } = taskModelCosts[category][model];\n      if (qualityScore >= 0.8 && cost < lowestCost) {\n        bestModel = model;\n        lowestCost = cost;\n      }\n    }\n    \n    if (bestModel) {\n      optimalMix[category] = {\n        recommendedModel: bestModel,\n        monthlyCost: lowestCost,\n        monthlyTokens: {\n          input: monthlyRequests * (taskCategories[category].percentage / 100) * taskCategories[category].avgInputTokens,\n          output: monthlyRequests * (taskCategories[category].percentage / 100) * taskCategories[category].avgOutputTokens\n        }\n      };\n      totalCost += lowestCost;\n    } else {\n      // Wenn kein passendes Modell gefunden wurde, verwende das günstigste Cloud-Modell\n      const cloudModels = validModels.filter(model => llmCostDb[model].type === 'cloud');\n      let fallbackModel = cloudModels[0];\n      \n      for (const model of cloudModels) {\n        if (taskModelCosts[category][model] && \n            taskModelCosts[category][model].cost < taskModelCosts[category][fallbackModel].cost) {\n          fallbackModel = model;\n        }\n      }\n      \n      const fallbackCost = taskModelCosts[category][fallbackModel].cost;\n      optimalMix[category] = {\n        recommendedModel: fallbackModel,\n        monthlyCost: fallbackCost,\n        monthlyTokens: {\n          input: monthlyRequests * (taskCategories[category].percentage / 100) * taskCategories[category].avgInputTokens,\n          output: monthlyRequests * (taskCategories[category].percentage / 100) * taskCategories[category].avgOutputTokens\n        },\n        note: \"Fallback zu Cloud-Modell, da kein lokales Modell den Anforderungen entspricht\"\n      };\n      totalCost += fallbackCost;\n    }\n  }\n  \n  return {\n    optimalMix,\n    totalMonthlyCost: totalCost,\n    projectedAnnualCost: totalCost * 12,\n    estimatedSavings: calculateSavingsVsCloudOnly(optimalMix, taskCategories, monthlyRequests)\n  };\n}\n\n// Berechnung der Einsparungen im Vergleich zu reiner Cloud-Nutzung\nfunction calculateSavingsVsCloudOnly(optimalMix, taskCategories, monthlyRequests) {\n  // Bestimme das günstigste Cloud-Modell für die Kostenschätzung\n  let cheapestCloudModel = null;\n  let cheapestInputCost = Infinity;\n  let cheapestOutputCost = Infinity;\n  \n  for (const model in llmCostDb) {\n    const modelInfo = llmCostDb[model];\n    if (modelInfo.type === 'cloud') {\n      const totalCostPerToken = modelInfo.inputCost + modelInfo.outputCost;\n      if (totalCostPerToken < (cheapestInputCost + cheapestOutputCost)) {\n        cheapestCloudModel = model;\n        cheapestInputCost = modelInfo.inputCost;\n        cheapestOutputCost = modelInfo.outputCost;\n      }\n    }\n  }\n  \n  // Berechne die Gesamtkosten für alle Tasks mit dem günstigsten Cloud-Modell\n  let cloudOnlyCost = 0;\n  \n  for (const category in taskCategories) {\n    const taskInfo = taskCategories[category];\n    const monthlyInputTokens = monthlyRequests * (taskInfo.percentage / 100) * taskInfo.avgInputTokens;\n    const monthlyOutputTokens = monthlyRequests * (taskInfo.percentage / 100) * taskInfo.avgOutputTokens;\n    \n    const inputCost = (monthlyInputTokens / 1000000) * cheapestInputCost;\n    const outputCost = (monthlyOutputTokens / 1000000) * cheapestOutputCost;\n    \n    cloudOnlyCost += (inputCost + outputCost);\n  }\n  \n  // Berechne die Einsparungen\n  const totalMixCost = Object.values(optimalMix).reduce((sum, item) => sum + item.monthlyCost, 0);\n  const monthlySavings = cloudOnlyCost - totalMixCost;\n  const savingsPercentage = (monthlySavings / cloudOnlyCost) * 100;\n  \n  return {\n    cloudOnlyMonthlyCost: cloudOnlyCost,\n    monthlySavings,\n    annualSavings: monthlySavings * 12,\n    savingsPercentage\n  };\n}\n\n// Hauptfunktion zur Verarbeitung der eingehenden Anfrage\nfunction processRequest(requestData) {\n  const { action, data } = requestData;\n  \n  switch (action) {\n    case 'compareModels':\n      return { result: compareModels(data) };\n      \n    case 'projectCosts':\n      return { result: projectCosts(data) };\n      \n    case 'findOptimalMix':\n      return { result: findOptimalModelMix(data) };\n      \n    case 'getAvailableModels':\n      return { result: Object.keys(llmCostDb).map(model => ({\n        id: model,\n        type: llmCostDb[model].type,\n        maxContext: llmCostDb[model].maxContext,\n        ...llmCostDb[model]\n      })) };\n      \n    default:\n      return { error: `Unbekannte Aktion: ${action}` };\n  }\n}\n\n// Verarbeite die Anfrage\nconst result = processRequest($input.item.json);\nreturn result;"
      },
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [440, 300],
      "id": "process-cost-analysis"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "visualize-costs",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 500],
      "id": "visualize-costs-webhook"
    },
    {
      "parameters": {
        "functionCode": "// Visualisierungsfunktionen für Kostenanalyse\nconst data = $input.item.json.data;\nconst chartType = $input.item.json.chartType || 'bar';\n\n// Verschiedene Chart-Typen implementieren\nlet chartData;\nlet chartOptions;\nlet chartTitle;\n\nfunction generateBarChartData(data, title = 'Kostenvergleich') {\n  // Nehme an, dass das Format ein Modellvergleich ist\n  const labels = Object.keys(data);\n  const costs = labels.map(model => {\n    if (data[model].error) return 0;\n    return data[model].totalCost;\n  });\n  \n  // Ist es ein Cloud vs. Lokaler Modellvergleich?\n  const isCloudVsLocalComparison = labels.some(model => data[model].type === 'cloud') && \n                                  labels.some(model => data[model].type === 'local');\n  \n  const backgroundColors = labels.map(model => {\n    if (data[model].error) return '#CCCCCC';\n    if (isCloudVsLocalComparison) {\n      return data[model].type === 'cloud' ? '#FF6384' : '#36A2EB';\n    }\n    // Zufällige Farben für andere Vergleiche\n    return `#${Math.floor(Math.random()*16777215).toString(16)}`;\n  });\n  \n  return {\n    type: 'bar',\n    data: {\n      labels,\n      datasets: [{\n        label: 'Kosten (€)',\n        data: costs,\n        backgroundColor: backgroundColors\n      }]\n    },\n    options: {\n      responsive: true,\n      title: {\n        display: true,\n        text: title\n      },\n      scales: {\n        yAxes: [{\n          ticks: {\n            beginAtZero: true,\n            callback: function(value) {\n              return '€' + value.toFixed(2);\n            }\n          },\n          scaleLabel: {\n            display: true,\n            labelString: 'Kosten (€)'\n          }\n        }]\n      }\n    }\n  };\n}\n\nfunction generateLineChartData(data, title = 'Kostenprojektion') {\n  // Nehme an, dass das Format eine Zeitprojektion ist\n  const datasets = [];\n  \n  for (const model in data) {\n    if (data[model].error) continue;\n    \n    const monthlyData = data[model];\n    const modelData = {\n      label: model,\n      data: monthlyData.map(m => m.cost),\n      borderColor: `#${Math.floor(Math.random()*16777215).toString(16)}`,\n      fill: false\n    };\n    \n    datasets.push(modelData);\n  }\n  \n  // Bestimme die Monatslabels basierend auf dem ersten Modell\n  const firstModel = Object.keys(data)[0];\n  const months = data[firstModel].map(m => `Monat ${m.month}`);\n  \n  return {\n    type: 'line',\n    data: {\n      labels: months,\n      datasets\n    },\n    options: {\n      responsive: true,\n      title: {\n        display: true,\n        text: title\n      },\n      scales: {\n        yAxes: [{\n          ticks: {\n            callback: function(value) {\n              return '€' + value.toFixed(2);\n            }\n          },\n          scaleLabel: {\n            display: true,\n            labelString: 'Kosten (€)'\n          }\n        }]\n      }\n    }\n  };\n}\n\nfunction generatePieChartData(data, title = 'Kostenverteilung') {\n  // Für optimale Modellmix-Visualisierung\n  if (data.optimalMix) {\n    const labels = Object.keys(data.optimalMix);\n    const costs = labels.map(category => data.optimalMix[category].monthlyCost);\n    \n    // Generiere zufällige Farben für jede Kategorie\n    const backgroundColors = labels.map(() => \n      `#${Math.floor(Math.random()*16777215).toString(16)}`\n    );\n    \n    return {\n      type: 'pie',\n      data: {\n        labels,\n        datasets: [{\n          data: costs,\n          backgroundColor: backgroundColors\n        }]\n      },\n      options: {\n        responsive: true,\n        title: {\n          display: true,\n          text: title\n        },\n        tooltips: {\n          callbacks: {\n            label: function(tooltipItem, data) {\n              const value = data.datasets[0].data[tooltipItem.index];\n              const label = data.labels[tooltipItem.index];\n              const model = data.optimalMix[label].recommendedModel;\n              return `${label} (${model}): €${value.toFixed(2)}`;\n            }\n          }\n        }\n      }\n    };\n  }\n  \n  // Standardversion für einfache Kostenvergleiche\n  const labels = Object.keys(data);\n  const costs = labels.map(key => {\n    if (data[key].error) return 0;\n    return data[key].totalCost;\n  });\n  \n  const backgroundColors = labels.map(() => \n    `#${Math.floor(Math.random()*16777215).toString(16)}`\n  );\n  \n  return {\n    type: 'pie',\n    data: {\n      labels,\n      datasets: [{\n        data: costs,\n        backgroundColor: backgroundColors\n      }]\n    },\n    options: {\n      responsive: true,\n      title: {\n        display: true,\n        text: title\n      }\n    }\n  };\n}\n\n// Wähle die Visualisierung basierend auf dem angeforderten Typ\nswitch(chartType) {\n  case 'bar':\n    chartData = generateBarChartData(data, $input.item.json.title);\n    break;\n    \n  case 'line':\n    chartData = generateLineChartData(data, $input.item.json.title);\n    break;\n    \n  case 'pie':\n    chartData = generatePieChartData(data, $input.item.json.title);\n    break;\n    \n  default:\n    return { error: `Unbekannter Chart-Typ: ${chartType}` };\n}\n\n// Generiere ein Base64-kodiertes Bild oder JSON für den Chart\nreturn {\n  chartData,\n  base64Image: null,  // In einer realen Implementierung könnte hier ein Base64-kodiertes Bild sein\n  chartType\n};"
      },
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [440, 500],
      "id": "generate-visualization"
    },
    {
      "parameters": {
        "functionCode": "// Generiere eine HTML-Vorschau für die Visualisierung\nconst chartData = $input.item.json.chartData;\nconst chartType = $input.item.json.chartType;\n\n// Einfache HTML-Vorschau mit Chart.js\nconst html = `<!DOCTYPE html>\n<html>\n<head>\n  <title>Kostenvisualisierung</title>\n  <script src=\"https://cdn.jsdelivr.net/npm/chart.js@2.9.4/dist/Chart.min.js\"></script>\n  <style>\n    body { font-family: Arial, sans-serif; margin: 20px; }\n    .chart-container { width: 800px; height: 500px; margin: 0 auto; }\n  </style>\n</head>\n<body>\n  <div class=\"chart-container\">\n    <canvas id=\"costChart\"></canvas>\n  </div>\n  \n  <script>\n    const ctx = document.getElementById('costChart').getContext('2d');\n    const chartConfig = ${JSON.stringify(chartData)};\n    new Chart(ctx, chartConfig);\n  </script>\n</body>\n</html>`;\n\nreturn {\n  html,\n  chartData,\n  chartType\n};"
      },
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [640, 500],
      "id": "generate-chart-preview"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "optimize-model-mix",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 700],
      "id": "optimize-mix-webhook"
    },
    {
      "parameters": {
        "functionCode": "// Funktion zur Optimierung des Modellmixes für verschiedene Task-Kategorien\nconst requestData = $input.item.json;\n\n// Stelle sicher, dass die Module aus der Hauptfunktion verfügbar sind\nconst llmCostDb = {\n  // Cloud Modelle\n  \"claude-3-5-sonnet\": {\n    \"type\": \"cloud\",\n    \"inputCost\": 3.0, // pro 1M Token\n    \"outputCost\": 15.0, // pro 1M Token\n    \"maxContext\": 200000,\n    \"provider\": \"anthropic\",\n    \"qualityScore\": 9.5\n  },\n  \"claude-3-opus\": {\n    \"type\": \"cloud\",\n    \"inputCost\": 15.0,\n    \"outputCost\": 75.0,\n    \"maxContext\": 200000,\n    \"provider\": \"anthropic\",\n    \"qualityScore\": 10.0\n  },\n  \"gpt-4o\": {\n    \"type\": \"cloud\",\n    \"inputCost\": 10.0,\n    \"outputCost\": 30.0,\n    \"maxContext\": 128000,\n    \"provider\": \"openai\",\n    \"qualityScore\": 9.5\n  },\n  \"gpt-4o-mini\": {\n    \"type\": \"cloud\",\n    \"inputCost\": 5.0,\n    \"outputCost\": 15.0,\n    \"maxContext\": 128000,\n    \"provider\": \"openai\",\n    \"qualityScore\": 9.0\n  },\n  \n  // Lokale Modelle\n  \"local-1.5b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 1500,  // Anschaffungskosten in Euro\n    \"powerConsumptionW\": 150,  // Watt\n    \"inferenceSpeed\": 100,  // Tokens/Sekunde\n    \"maxContext\": 4096,\n    \"maintenanceCostPerMonth\": 50,\n    \"qualityScore\": 5.0\n  },\n  \"local-3b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 2000,\n    \"powerConsumptionW\": 200,\n    \"inferenceSpeed\": 70,\n    \"maxContext\": 8192,\n    \"maintenanceCostPerMonth\": 75,\n    \"qualityScore\": 6.0\n  },\n  \"local-7b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 2500,\n    \"powerConsumptionW\": 300,\n    \"inferenceSpeed\": 50,\n    \"maxContext\": 8192,\n    \"maintenanceCostPerMonth\": 100,\n    \"qualityScore\": 7.0\n  },\n  \"local-13b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 3000,\n    \"powerConsumptionW\": 400,\n    \"inferenceSpeed\": 30,\n    \"maxContext\": 16384,\n    \"maintenanceCostPerMonth\": 150,\n    \"qualityScore\": 7.5\n  },\n  \"local-34b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 8000,\n    \"powerConsumptionW\": 800,\n    \"inferenceSpeed\": 15,\n    \"maxContext\": 32768,\n    \"maintenanceCostPerMonth\": 300,\n    \"qualityScore\": 8.5\n  },\n  \"local-70b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 20000,\n    \"powerConsumptionW\": 1200,\n    \"inferenceSpeed\": 8,\n    \"maxContext\": 65536,\n    \"maintenanceCostPerMonth\": 500,\n    \"qualityScore\": 9.0\n  }\n};\n\n// Optimierungsalgorithmus für den Modellmix\nfunction optimizeModelMix(data) {\n  const {\n    availableModels = Object.keys(llmCostDb),\n    taskDistribution = {},\n    constraints = {},\n    monthlyRequestVolume = 100000,\n    optimizationTarget = 'cost',  // 'cost', 'quality', 'balanced'\n    budgetLimit = null,\n    existingHardware = [],\n    energyCostPerKWh = 0.30,\n    amortizationPeriodMonths = 36\n  } = data;\n  \n  // Filtere verfügbare Modelle basierend auf Constraints\n  const eligibleModels = availableModels.filter(model => {\n    const modelInfo = llmCostDb[model];\n    if (!modelInfo) return false;\n    \n    // Prüfe Kontext-Constraints\n    if (constraints.minContextSize && modelInfo.maxContext < constraints.minContextSize) {\n      return false;\n    }\n    \n    // Prüfe Qualitäts-Constraints\n    if (constraints.minQualityScore && modelInfo.qualityScore < constraints.minQualityScore) {\n      return false;\n    }\n    \n    // Prüfe Typ-Constraints (nur lokale oder nur Cloud-Modelle)\n    if (constraints.onlyLocalModels && modelInfo.type !== 'local') {\n      return false;\n    }\n    if (constraints.onlyCloudModels && modelInfo.type !== 'cloud') {\n      return false;\n    }\n    \n    return true;\n  });\n  \n  // Prüfe, ob existierende Hardware vorhanden ist\n  const existingModelCapacity = {};\n  \n  for (const hardware of existingHardware) {\n    const { modelType, instanceCount = 1 } = hardware;\n    if (llmCostDb[modelType] && llmCostDb[modelType].type === 'local') {\n      existingModelCapacity[modelType] = instanceCount;\n    }\n  }\n  \n  // Berechne optimalen Mix für jede Task-Kategorie\n  const result = {};\n  let totalMonthlyCost = 0;\n  let totalQualityScore = 0;\n  const totalTasks = Object.values(taskDistribution).reduce((sum, task) => sum + task.percentage, 0);\n  \n  for (const [taskName, taskInfo] of Object.entries(taskDistribution)) {\n    const { \n      percentage, \n      avgInputTokens, \n      avgOutputTokens, \n      minQualityRequired = 5.0,\n      minContextRequired = 0,\n      importance = 1 // Wichtigkeit der Task (1-10)\n    } = taskInfo;\n    \n    // Berechne monatliche Token für diese Task-Kategorie\n    const monthlyTaskRequests = monthlyRequestVolume * (percentage / 100);\n    const monthlyInputTokens = monthlyTaskRequests * avgInputTokens;\n    const monthlyOutputTokens = monthlyTaskRequests * avgOutputTokens;\n    \n    // Filtere Modelle nach Task-spezifischen Anforderungen\n    const taskEligibleModels = eligibleModels.filter(model => {\n      const modelInfo = llmCostDb[model];\n      return modelInfo.qualityScore >= minQualityRequired && \n             modelInfo.maxContext >= minContextRequired;\n    });\n    \n    if (taskEligibleModels.length === 0) {\n      result[taskName] = {\n        error: 'Keine geeigneten Modelle gefunden',\n        requirements: { minQualityRequired, minContextRequired }\n      };\n      continue;\n    }\n    \n    // Berechne Kosten und Qualität für jedes geeignete Modell\n    const modelScores = {};\n    \n    for (const model of taskEligibleModels) {\n      const modelInfo = llmCostDb[model];\n      let costScore, qualityScore, balancedScore;\n      \n      if (modelInfo.type === 'cloud') {\n        // Cloud-Modell-Kosten\n        const inputCost = (monthlyInputTokens / 1000000) * modelInfo.inputCost;\n        const outputCost = (monthlyOutputTokens / 1000000) * modelInfo.outputCost;\n        const totalCost = inputCost + outputCost;\n        \n        costScore = 1 / (totalCost + 1);  // Umgekehrt proportional zu den Kosten\n        qualityScore = modelInfo.qualityScore / 10;  // Normalisiert auf 0-1\n        balancedScore = (costScore + qualityScore) / 2;\n        \n        modelScores[model] = {\n          model,\n          monthlyCost: totalCost,\n          qualityScore: modelInfo.qualityScore,\n          costScore,\n          qualityScore,\n          balancedScore,\n          type: 'cloud'\n        };\n      } else {\n        // Lokales Modell - Berücksichtige Anschaffungs- und Betriebskosten\n        let hardwareCost;\n        \n        if (existingModelCapacity[model] && existingModelCapacity[model] > 0) {\n          // Hardware bereits vorhanden\n          hardwareCost = 0;\n          // Reduziere die verfügbare Kapazität\n          existingModelCapacity[model]--;\n        } else {\n          // Neue Hardware erforderlich\n          hardwareCost = modelInfo.hardwareCost / amortizationPeriodMonths;\n        }\n        \n        // Berechne Energiekosten\n        const processingHours = (monthlyInputTokens + monthlyOutputTokens) / \n                               (modelInfo.inferenceSpeed * 3600);\n        const energyCost = (modelInfo.powerConsumptionW / 1000) * processingHours * energyCostPerKWh;\n        \n        const totalCost = hardwareCost + energyCost + modelInfo.maintenanceCostPerMonth;\n        \n        costScore = 1 / (totalCost + 1);\n        qualityScore = modelInfo.qualityScore / 10;\n        balancedScore = (costScore + qualityScore) / 2;\n        \n        modelScores[model] = {\n          model,\n          monthlyCost: totalCost,\n          qualityScore: modelInfo.qualityScore,\n          costScore,\n          qualityScore,\n          balancedScore,\n          type: 'local',\n          details: {\n            hardwareCost,\n            energyCost,\n            maintenanceCost: modelInfo.maintenanceCostPerMonth\n          }\n        };\n      }\n    }\n    \n    // Wähle das beste Modell basierend auf dem Optimierungsziel\n    let bestModel, bestScore = -Infinity;\n    \n    for (const [model, scores] of Object.entries(modelScores)) {\n      let currentScore;\n      \n      switch(optimizationTarget) {\n        case 'cost':\n          currentScore = scores.costScore;\n          break;\n        case 'quality':\n          currentScore = scores.qualityScore;\n          break;\n        case 'balanced':\n        default:\n          currentScore = scores.balancedScore;\n          break;\n      }\n      \n      // Gewichte mit der Wichtigkeit der Task\n      currentScore *= importance;\n      \n      if (currentScore > bestScore) {\n        bestScore = currentScore;\n        bestModel = model;\n      }\n    }\n    \n    // Speichere Ergebnisse\n    const selectedModelInfo = modelScores[bestModel];\n    result[taskName] = {\n      recommendedModel: bestModel,\n      monthlyCost: selectedModelInfo.monthlyCost,\n      qualityScore: selectedModelInfo.qualityScore,\n      modelType: selectedModelInfo.type,\n      tokenCounts: {\n        input: monthlyInputTokens,\n        output: monthlyOutputTokens,\n        total: monthlyInputTokens + monthlyOutputTokens\n      }\n    };\n    \n    // Aktualisiere Gesamtkosten und -qualität\n    totalMonthlyCost += selectedModelInfo.monthlyCost;\n    totalQualityScore += (selectedModelInfo.qualityScore * (percentage / totalTasks));\n  }\n  \n  // Cloud-Only-Kosten für Vergleich berechnen\n  const cloudOnlyCost = calculateCloudOnlyCost(taskDistribution, monthlyRequestVolume);\n  \n  // Berechne ROI und Amortisationszeit\n  const monthlySavings = cloudOnlyCost - totalMonthlyCost;\n  const totalHardwareCost = calculateTotalHardwareInvestment(result);\n  const roi = (monthlySavings * 12) / totalHardwareCost * 100; // ROI im ersten Jahr\n  const amortizationMonths = totalHardwareCost / monthlySavings;\n  \n  return {\n    taskAllocation: result,\n    summary: {\n      totalMonthlyCost,\n      annualCost: totalMonthlyCost * 12,\n      averageQualityScore: totalQualityScore,\n      cloudOnlyCost,\n      monthlySavings,\n      annualSavings: monthlySavings * 12,\n      savingsPercentage: (monthlySavings / cloudOnlyCost) * 100,\n      requiredHardwareInvestment: totalHardwareCost,\n      roi,\n      amortizationMonths,\n      optimizationTarget\n    }\n  };\n}\n\n// Berechne die Kosten für eine reine Cloud-Lösung\nfunction calculateCloudOnlyCost(taskDistribution, monthlyRequestVolume) {\n  // Bestimme das kostengünstigste Cloud-Modell\n  let cheapestCloudModel = null;\n  let lowestCombinedRate = Infinity;\n  \n  for (const [model, info] of Object.entries(llmCostDb)) {\n    if (info.type === 'cloud') {\n      const combinedRate = info.inputCost + info.outputCost;\n      if (combinedRate < lowestCombinedRate) {\n        lowestCombinedRate = combinedRate;\n        cheapestCloudModel = model;\n      }\n    }\n  }\n  \n  if (!cheapestCloudModel) return 0; // Keine Cloud-Modelle verfügbar\n  \n  const modelInfo = llmCostDb[cheapestCloudModel];\n  let totalCost = 0;\n  \n  // Berechne die Kosten für jede Task-Kategorie\n  for (const [_, taskInfo] of Object.entries(taskDistribution)) {\n    const { percentage, avgInputTokens, avgOutputTokens } = taskInfo;\n    \n    const monthlyTaskRequests = monthlyRequestVolume * (percentage / 100);\n    const monthlyInputTokens = monthlyTaskRequests * avgInputTokens;\n    const monthlyOutputTokens = monthlyTaskRequests * avgOutputTokens;\n    \n    const inputCost = (monthlyInputTokens / 1000000) * modelInfo.inputCost;\n    const outputCost = (monthlyOutputTokens / 1000000) * modelInfo.outputCost;\n    \n    totalCost += (inputCost + outputCost);\n  }\n  \n  return totalCost;\n}\n\n// Berechne die erforderliche Hardware-Investition\nfunction calculateTotalHardwareInvestment(result) {\n  const requiredModels = {};\n  \n  // Zähle, wie viele Instanzen jedes lokalen Modells benötigt werden\n  for (const [_, taskInfo] of Object.entries(result)) {\n    if (taskInfo.modelType === 'local') {\n      const model = taskInfo.recommendedModel;\n      requiredModels[model] = (requiredModels[model] || 0) + 1;\n    }\n  }\n  \n  // Berechne die Gesamtkosten\n  let totalCost = 0;\n  for (const [model, count] of Object.entries(requiredModels)) {\n    totalCost += llmCostDb[model].hardwareCost * count;\n  }\n  \n  return totalCost;\n}\n\n// Führe die Optimierung durch\nconst optimizationResult = optimizeModelMix(requestData);\nreturn optimizationResult;"
      },
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [440, 700],
      "id": "optimize-model-mix"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "roi-calculator",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 900],
      "id": "roi-calculator-webhook"
    },
    {
      "parameters": {
        "functionCode": "// ROI-Berechnungen für lokale LLM-Investitionen\nconst requestData = $input.item.json;\n\n// Standardwerte, falls nicht angegeben\nconst data = {\n  initialInvestment: requestData.initialInvestment || 0,\n  monthlyCloudCosts: requestData.monthlyCloudCosts || 0,\n  monthlyLocalCosts: requestData.monthlyLocalCosts || 0,\n  growthRatePercent: requestData.growthRatePercent || 0,\n  inflationRatePercent: requestData.inflationRatePercent || 2,\n  discountRatePercent: requestData.discountRatePercent || 5,\n  timeframeMonths: requestData.timeframeMonths || 36,\n  hardwareLifespanMonths: requestData.hardwareLifespanMonths || 48,\n  taxRatePercent: requestData.taxRatePercent || 30,\n  depreciationMethod: requestData.depreciationMethod || 'linear'\n};\n\n// Berechne ROI und weitere Finanzkennzahlen\nfunction calculateFinancialMetrics() {\n  const results = {\n    monthlyAnalysis: [],\n    summary: {}\n  };\n  \n  let cumulativeSavings = 0;\n  let cumulativeDiscountedSavings = 0;\n  let npv = -data.initialInvestment;\n  \n  // Monatliche Analyse\n  for (let month = 1; month <= data.timeframeMonths; month++) {\n    // Anpassung der Kosten basierend auf Wachstum und Inflation\n    const growthFactor = Math.pow(1 + data.growthRatePercent / 100, month / 12);\n    const inflationFactor = Math.pow(1 + data.inflationRatePercent / 100, month / 12);\n    \n    const adjustedCloudCosts = data.monthlyCloudCosts * growthFactor * inflationFactor;\n    const adjustedLocalCosts = data.monthlyLocalCosts * growthFactor * inflationFactor;\n    \n    // Monatliche Einsparungen\n    const monthlySavings = adjustedCloudCosts - adjustedLocalCosts;\n    \n    // Diskontierte Einsparungen (Present Value)\n    const discountFactor = Math.pow(1 + data.discountRatePercent / 100, -month / 12);\n    const discountedSavings = monthlySavings * discountFactor;\n    \n    // Abschreibungen berechnen\n    let depreciation = 0;\n    if (month <= data.hardwareLifespanMonths) {\n      if (data.depreciationMethod === 'linear') {\n        depreciation = data.initialInvestment / data.hardwareLifespanMonths;\n      } else if (data.depreciationMethod === 'accelerated') {\n        // Doppelt abnehmende Bilanz-Methode\n        const rate = 2 / data.hardwareLifespanMonths;\n        const remainingValue = data.initialInvestment * Math.pow(1 - rate, month - 1);\n        depreciation = remainingValue * rate;\n      }\n    }\n    \n    // Steuervorteil durch Abschreibung\n    const taxSavings = depreciation * (data.taxRatePercent / 100);\n    \n    // Netto-Cashflow nach Steuern\n    const netCashflow = monthlySavings + taxSavings;\n    \n    // Kumulierte Werte\n    cumulativeSavings += monthlySavings;\n    cumulativeDiscountedSavings += discountedSavings;\n    npv += discountedSavings;\n    \n    // Monatliche Daten speichern\n    results.monthlyAnalysis.push({\n      month,\n      cloudCosts: adjustedCloudCosts,\n      localCosts: adjustedLocalCosts,\n      savings: monthlySavings,\n      discountedSavings,\n      depreciation,\n      taxSavings,\n      netCashflow,\n      cumulativeSavings,\n      cumulativeDiscountedSavings,\n      npvAtMonth: npv\n    });\n  }\n  \n  // Zusammenfassung berechnen\n  \n  // Break-Even-Punkt (Payback-Periode)\n  let paybackMonth = null;\n  for (let i = 0; i < results.monthlyAnalysis.length; i++) {\n    if (results.monthlyAnalysis[i].cumulativeSavings >= data.initialInvestment) {\n      paybackMonth = i + 1;\n      break;\n    }\n  }\n  \n  // Diskontierte Payback-Periode\n  let discountedPaybackMonth = null;\n  for (let i = 0; i < results.monthlyAnalysis.length; i++) {\n    if (results.monthlyAnalysis[i].cumulativeDiscountedSavings >= data.initialInvestment) {\n      discountedPaybackMonth = i + 1;\n      break;\n    }\n  }\n  \n  // Return on Investment (ROI)\n  const roi = (cumulativeSavings - data.initialInvestment) / data.initialInvestment * 100;\n  \n  // Internal Rate of Return (IRR) - approximation\n  let irr = calculateIRR(\n    [...Array(data.timeframeMonths).keys()].map(month => results.monthlyAnalysis[month].netCashflow),\n    data.initialInvestment\n  );\n  \n  // Zusammenfassung\n  results.summary = {\n    initialInvestment: data.initialInvestment,\n    totalSavings: cumulativeSavings,\n    netPresentValue: npv,\n    roi,\n    paybackPeriodMonths: paybackMonth,\n    discountedPaybackPeriodMonths: discountedPaybackMonth,\n    annualizedROI: (Math.pow(1 + roi / 100, 12 / data.timeframeMonths) - 1) * 100,\n    monthlyAverageSavings: cumulativeSavings / data.timeframeMonths,\n    irr: irr * 100 // in Prozent\n  };\n  \n  return results;\n}\n\n// Näherungsweise Berechnung des internen Zinsfußes (IRR)\nfunction calculateIRR(cashflows, initialInvestment) {\n  // Startwert für die Iteration\n  let guess = 0.1;\n  const maxIterations = 100;\n  const tolerance = 0.0001;\n  \n  // Newton-Raphson-Verfahren für die Nullstellensuche\n  for (let i = 0; i < maxIterations; i++) {\n    let npv = -initialInvestment;\n    let derivativeNpv = 0;\n    \n    for (let t = 0; t < cashflows.length; t++) {\n      const discountFactor = Math.pow(1 + guess, -(t + 1) / 12); // Monatlicher Diskontsatz\n      npv += cashflows[t] * discountFactor;\n      derivativeNpv -= (t + 1) / 12 * cashflows[t] * discountFactor / (1 + guess);\n    }\n    \n    // Prüfe auf Konvergenz\n    if (Math.abs(npv) < tolerance) {\n      return guess;\n    }\n    \n    // Aktualisiere Schätzung\n    guess = guess - npv / derivativeNpv;\n    \n    // Verhindere negative Zinssätze\n    if (guess < -0.99) {\n      guess = -0.99;\n    }\n  }\n  \n  // Fallback, wenn keine Konvergenz erreicht wurde\n  return guess;\n}\n\n// Führe die Berechnungen durch\nconst financialResults = calculateFinancialMetrics();\nreturn financialResults;"
      },
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [440, 900],
      "id": "calculate-roi"
    },
    {
      "parameters": {
        "functionCode": "// Generiere einen detaillierten Finanzbericht\nconst roiData = $input.item.json;\n\n// Extrahiere die wichtigsten Daten\nconst summary = roiData.summary;\nconst monthlyData = roiData.monthlyAnalysis;\n\n// Formatierungsfunktionen\nfunction formatCurrency(value) {\n  return `€${value.toFixed(2)}`;\n}\n\nfunction formatPercent(value) {\n  return `${value.toFixed(2)}%`;\n}\n\nfunction formatMonth(months) {\n  const years = Math.floor(months / 12);\n  const remainingMonths = months % 12;\n  \n  if (years === 0) {\n    return `${remainingMonths} Monate`;\n  } else if (remainingMonths === 0) {\n    return `${years} Jahre`;\n  } else {\n    return `${years} Jahre, ${remainingMonths} Monate`;\n  }\n}\n\n// Erstelle den Bericht\nconst report = {\n  title: \"ROI-Analyse für lokale LLM-Investition\",\n  executiveSummary: {\n    initialInvestment: formatCurrency(summary.initialInvestment),\n    totalSavings: formatCurrency(summary.totalSavings),\n    netPresentValue: formatCurrency(summary.netPresentValue),\n    roi: formatPercent(summary.roi),\n    annualizedROI: formatPercent(summary.annualizedROI),\n    paybackPeriod: formatMonth(summary.paybackPeriodMonths),\n    irr: formatPercent(summary.irr)\n  },\n  keyInsights: [\n    summary.netPresentValue > 0 ? \n      \"Die Investition ist finanziell vorteilhaft mit einem positiven Kapitalwert.\" :\n      \"Die Investition erreicht keinen positiven Kapitalwert im betrachteten Zeitraum.\",\n    summary.paybackPeriodMonths ? \n      `Break-Even wird nach ${formatMonth(summary.paybackPeriodMonths)} erreicht.` :\n      \"Die Investition erreicht im betrachteten Zeitraum keinen Break-Even.\",\n    summary.irr > 10 ?\n      \"Die Rendite ist überdurchschnittlich hoch und die Investition sehr attraktiv.\" :\n      summary.irr > 0 ?\n        \"Die Rendite ist positiv, aber moderat.\" :\n        \"Die Rendite liegt unter den Erwartungen.\"\n  ],\n  financialSummary: {\n    monthlySavings: formatCurrency(summary.monthlyAverageSavings),\n    yearlyNetImpact: formatCurrency(summary.monthlyAverageSavings * 12),\n    fiveYearProjection: formatCurrency(summary.monthlyAverageSavings * 60)\n  },\n  quarterlyBreakdown: generateQuarterlyBreakdown(monthlyData),\n  recommendation: generateRecommendation(summary)\n};\n\n// Generiere eine vierteljährliche Zusammenfassung\nfunction generateQuarterlyBreakdown(monthlyData) {\n  const quarters = [];\n  const quarterCount = Math.ceil(monthlyData.length / 3);\n  \n  for (let i = 0; i < quarterCount; i++) {\n    const startIdx = i * 3;\n    const endIdx = Math.min(startIdx + 2, monthlyData.length - 1);\n    \n    if (startIdx >= monthlyData.length)

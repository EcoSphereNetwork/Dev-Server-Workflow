{
  "name": "Task-Cost-Estimation",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "estimate-task-cost",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 300],
      "id": "task-cost-webhook"
    },
    {
      "parameters": {
        "functionCode": "// Hauptfunktion zur Schätzung der Kosten basierend auf Aufgabenkomplexität\nconst taskRequest = $input.item.json;\n\n// Modell-Datenbank mit Kosten und Funktionen\nconst modelDb = {\n  // Cloud-Modelle\n  \"claude-3-5-sonnet\": {\n    \"type\": \"cloud\",\n    \"provider\": \"anthropic\",\n    \"inputCost\": 3.0,     // € pro 1M Tokens\n    \"outputCost\": 15.0,   // € pro 1M Tokens\n    \"maxContext\": 200000,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 150,  // Tokens pro Sekunde\n    \"complexityHandling\": 9.5,    // 1-10 Skala\n    \"qualityScore\": 9.5,          // 1-10 Skala\n    \"multimodalCapable\": true\n  },\n  \"claude-3-opus\": {\n    \"type\": \"cloud\",\n    \"provider\": \"anthropic\",\n    \"inputCost\": 15.0,\n    \"outputCost\": 75.0,\n    \"maxContext\": 200000,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 100,\n    \"complexityHandling\": 10.0,\n    \"qualityScore\": 10.0,\n    \"multimodalCapable\": true\n  },\n  \"gpt-4o\": {\n    \"type\": \"cloud\",\n    \"provider\": \"openai\",\n    \"inputCost\": 10.0,\n    \"outputCost\": 30.0,\n    \"maxContext\": 128000,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 120,\n    \"complexityHandling\": 9.5,\n    \"qualityScore\": 9.5,\n    \"multimodalCapable\": true\n  },\n  \"gpt-4o-mini\": {\n    \"type\": \"cloud\",\n    \"provider\": \"openai\",\n    \"inputCost\": 5.0,\n    \"outputCost\": 15.0,\n    \"maxContext\": 128000,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 150,\n    \"complexityHandling\": 9.0,\n    \"qualityScore\": 8.8,\n    \"multimodalCapable\": true\n  },\n  \n  // Lokale Modelle\n  \"local-1.5b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 1500,          // Anschaffungskosten in €\n    \"powerConsumptionW\": 150,      // Watt\n    \"maxContext\": 2048,\n    \"maxOutput\": 2048,\n    \"tokenProcessingSpeed\": 100,    // Tokens pro Sekunde\n    \"complexityHandling\": 4.5,      // 1-10 Skala\n    \"qualityScore\": 5.0,            // 1-10 Skala\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 50\n  },\n  \"local-3b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 2000,\n    \"powerConsumptionW\": 200,\n    \"maxContext\": 4096,\n    \"maxOutput\": 2048,\n    \"tokenProcessingSpeed\": 80,\n    \"complexityHandling\": 5.5,\n    \"qualityScore\": 6.0,\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 75\n  },\n  \"local-7b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 2500,\n    \"powerConsumptionW\": 300,\n    \"maxContext\": 8192,\n    \"maxOutput\": 2048,\n    \"tokenProcessingSpeed\": 50,\n    \"complexityHandling\": 7.0,\n    \"qualityScore\": 7.5,\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 100\n  },\n  \"local-13b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 3000,\n    \"powerConsumptionW\": 400,\n    \"maxContext\": 8192,\n    \"maxOutput\": 2048,\n    \"tokenProcessingSpeed\": 30,\n    \"complexityHandling\": 7.5,\n    \"qualityScore\": 8.0,\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 125\n  },\n  \"local-34b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 7500,\n    \"powerConsumptionW\": 800,\n    \"maxContext\": 16384,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 15,\n    \"complexityHandling\": 8.5,\n    \"qualityScore\": 8.8,\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 200\n  },\n  \"local-70b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 15000,\n    \"powerConsumptionW\": 1200,\n    \"maxContext\": 32768,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 8,\n    \"complexityHandling\": 9.0,\n    \"qualityScore\": 9.2,\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 300\n  }\n};\n\n// Kompexitätskategorien mit typischen Token-Anforderungen\nconst complexityCategories = {\n  \"very_simple\": {\n    description: \"Sehr einfache Aufgaben: Klassifikation, kurze Antworten, einfache Fragen\",\n    avgInputTokens: 200,\n    avgOutputTokens: 100,\n    minComplexityHandling: 4.0,\n    requiredContextSize: 1024,\n    processingTimeMultiplier: 1.0\n  },\n  \"simple\": {\n    description: \"Einfache Aufgaben: Zusammenfassungen, kurze Texte, einfache Faktenrecherche\",\n    avgInputTokens: 1000,\n    avgOutputTokens: 300,\n    minComplexityHandling: 5.0,\n    requiredContextSize: 2048,\n    processingTimeMultiplier: 1.2\n  },\n  \"medium\": {\n    description: \"Mittlere Komplexität: Standard-Codegeneration, detaillierte Antworten, Analysen\",\n    avgInputTokens: 2000,\n    avgOutputTokens: 800,\n    minComplexityHandling: 6.5,\n    requiredContextSize: 4096,\n    processingTimeMultiplier: 1.5\n  },\n  \"complex\": {\n    description: \"Komplexe Aufgaben: Tiefe Textanalysen, fortgeschrittene Codegeneration, logisches Reasoning\",\n    avgInputTokens: 4000,\n    avgOutputTokens: 1500,\n    minComplexityHandling: 7.5,\n    requiredContextSize: 8192,\n    processingTimeMultiplier: 2.0\n  },\n  \"very_complex\": {\n    description: \"Sehr komplexe Aufgaben: Multi-step Reasoning, detaillierte Berichte, komplexe Problemlösung\",\n    avgInputTokens: 8000,\n    avgOutputTokens: 3000,\n    minComplexityHandling: 8.5,\n    requiredContextSize: 16384,\n    processingTimeMultiplier: 3.0\n  },\n  \"extremely_complex\": {\n    description: \"Extrem komplexe Aufgaben: Forschungssynthesen, hochkomplexe Logikketten, AI-Agenten-Systeme\",\n    avgInputTokens: 15000,\n    avgOutputTokens: 4000,\n    minComplexityHandling: 9.5,\n    requiredContextSize: 32768,\n    processingTimeMultiplier: 4.0\n  }\n};\n\n// Parameter aus dem Request extrahieren mit Defaults\nconst {\n  task_complexity = \"medium\",           // very_simple, simple, medium, complex, very_complex, extremely_complex\n  input_tokens,                        // Optional: Explizite Angabe von Eingabe-Tokens\n  output_tokens,                       // Optional: Explizite Angabe von Ausgabe-Tokens\n  context_length,                      // Optional: Explizite Angabe von Kontextlänge\n  models_to_evaluate = Object.keys(modelDb),  // Zu bewertende Modelle\n  require_multimodal = false,          // Multimodale Fähigkeiten erforderlich?\n  quality_threshold = 7.0,             // Mindestqualität (1-10)\n  energy_cost_per_kwh = 0.30,          // Energiekosten pro kWh\n  hardware_amortization_months = 36,   // Abschreibungszeitraum für Hardware in Monaten\n  include_hardware_costs = true,       // Hardware-Kosten einbeziehen?\n  custom_parameters = {}               // Zusätzliche benutzerdefinierte Parameter\n} = taskRequest;\n\n// Funktion zur Berechnung der Tokenisierungskosten für Cloud-Modelle\nfunction calculateCloudModelCost(model, inputTokenCount, outputTokenCount) {\n  const modelInfo = modelDb[model];\n  if (!modelInfo || modelInfo.type !== 'cloud') {\n    throw new Error(`Ungültiges Cloud-Modell: ${model}`);\n  }\n  \n  const inputCost = (inputTokenCount / 1000000) * modelInfo.inputCost;\n  const outputCost = (outputTokenCount / 1000000) * modelInfo.outputCost;\n  \n  // Abgelehnte Anfragen: Wenn der Kontextgröße > maxContext oder erforderliche Qualität > Modellqualität\n  const isRejected = (context_length && context_length > modelInfo.maxContext) || \n                     (quality_threshold && quality_threshold > modelInfo.qualityScore) ||\n                     (require_multimodal && !modelInfo.multimodalCapable);\n  \n  // Verarbeitungszeit in Sekunden\n  const processingTime = isRejected ? 0 : (inputTokenCount + outputTokenCount) / modelInfo.tokenProcessingSpeed;\n  \n  // Antwortlatenz (vereinfacht)\n  const latency = isRejected ? 0 : (processingTime + 1.5); // +1.5s für Netzwerklatenz\n\n  return {\n    inputCost,\n    outputCost,\n    totalCost: inputCost + outputCost,\n    processingTime,\n    latency,\n    isRejected,\n    rejectionReason: isRejected ? getCloudRejectionReason(modelInfo) : null\n  };\n}\n\n// Hilfsfunktion zur Bestimmung des Ablehnungsgrundes\nfunction getCloudRejectionReason(modelInfo) {\n  if (context_length && context_length > modelInfo.maxContext) {\n    return `Kontextgröße (${context_length}) überschreitet maximale Kontextgröße des Modells (${modelInfo.maxContext})`;\n  }\n  if (quality_threshold && quality_threshold > modelInfo.qualityScore) {\n    return `Erforderliche Qualität (${quality_threshold}) überschreitet Modellqualität (${modelInfo.qualityScore})`;\n  }\n  if (require_multimodal && !modelInfo.multimodalCapable) {\n    return \"Modell unterstützt keine multimodalen Aufgaben\";\n  }\n  return \"Unbekannter Grund\";\n}\n\n// Funktion zur Berechnung der Kosten für lokale Modelle\nfunction calculateLocalModelCost(model, inputTokenCount, outputTokenCount) {\n  const modelInfo = modelDb[model];\n  if (!modelInfo || modelInfo.type !== 'local') {\n    throw new Error(`Ungültiges lokales Modell: ${model}`);\n  }\n  \n  // Prüfen, ob das Modell die Anforderungen erfüllt\n  const isRejected = (context_length && context_length > modelInfo.maxContext) || \n                     (quality_threshold && quality_threshold > modelInfo.qualityScore) ||\n                     (require_multimodal && !modelInfo.multimodalCapable);\n  \n  if (isRejected) {\n    return {\n      energyCost: 0,\n      hardwareCost: 0,\n      maintenanceCost: 0,\n      totalCost: 0,\n      processingTime: 0,\n      latency: 0,\n      isRejected: true,\n      rejectionReason: getLocalRejectionReason(modelInfo)\n    };\n  }\n  \n  // Gesamte Tokenanzahl\n  const totalTokens = inputTokenCount + outputTokenCount;\n  \n  // Verarbeitungszeit unter Berücksichtigung der Aufgabenkomplexität\n  const complexityInfo = complexityCategories[task_complexity];\n  const adjustedProcessingTime = totalTokens / modelInfo.tokenProcessingSpeed * \n                                 complexityInfo.processingTimeMultiplier;\n  \n  // Energie- und Hardwarekosten\n  // Energieverbrauch in kWh\n  const energyConsumption = (modelInfo.powerConsumptionW / 1000) * (adjustedProcessingTime / 3600);\n  const energyCost = energyConsumption * energy_cost_per_kwh;\n  \n  // Hardware-Abschreibungskosten\n  let hardwareCost = 0;\n  if (include_hardware_costs) {\n    // Stündliche Hardware-Kosten basierend auf Abschreibungszeitraum\n    const hourlyHardwareCost = modelInfo.hardwareCost / (hardware_amortization_months * 30 * 24);\n    hardwareCost = hourlyHardwareCost * (adjustedProcessingTime / 3600);\n  }\n  \n  // Wartungskosten\n  const hourlyMaintenanceCost = modelInfo.maintenanceCostPerMonth / (30 * 24);\n  const maintenanceCost = hourlyMaintenanceCost * (adjustedProcessingTime / 3600);\n  \n  // Gesamtkosten\n  const totalCost = energyCost + hardwareCost + maintenanceCost;\n  \n  // Latenz ist bei lokalen Modellen gleich der Verarbeitungszeit\n  const latency = adjustedProcessingTime;\n  \n  return {\n    energyCost,\n    hardwareCost,\n    maintenanceCost,\n    totalCost,\n    energyConsumption,\n    processingTime: adjustedProcessingTime,\n    latency,\n    isRejected: false\n  };\n}\n\n// Hilfsfunktion zur Bestimmung des Ablehnungsgrundes für lokale Modelle\nfunction getLocalRejectionReason(modelInfo) {\n  if (context_length && context_length > modelInfo.maxContext) {\n    return `Kontextgröße (${context_length}) überschreitet maximale Kontextgröße des Modells (${modelInfo.maxContext})`;\n  }\n  if (quality_threshold && quality_threshold > modelInfo.qualityScore) {\n    return `Erforderliche Qualität (${quality_threshold}) überschreitet Modellqualität (${modelInfo.qualityScore})`;\n  }\n  if (require_multimodal && !modelInfo.multimodalCapable) {\n    return \"Modell unterstützt keine multimodalen Aufgaben\";\n  }\n  return \"Unbekannter Grund\";\n}\n\n// Hauptfunktion zur Berechnung der Kosten für verschiedene Modelle\nfunction estimateTaskCosts() {\n  // Bestimme die Tokens basierend auf Komplexität oder expliziten Angaben\n  let inputTokenCount, outputTokenCount, requiredContext;\n  \n  if (input_tokens && output_tokens) {\n    // Verwende explizit angegebene Token-Zahlen\n    inputTokenCount = input_tokens;\n    outputTokenCount = output_tokens;\n  } else {\n    // Verwende die durchschnittlichen Token-Zahlen basierend auf der Komplexitätskategorie\n    const complexityInfo = complexityCategories[task_complexity];\n    if (!complexityInfo) {\n      throw new Error(`Ungültige Komplexitätskategorie: ${task_complexity}`);\n    }\n    \n    inputTokenCount = complexityInfo.avgInputTokens;\n    outputTokenCount = complexityInfo.avgOutputTokens;\n    requiredContext = complexityInfo.requiredContextSize;\n  }\n  \n  // Verwende explizite Kontextlänge, falls angegeben, sonst die aus der Komplexitätskategorie\n  const effectiveContextLength = context_length || requiredContext;\n  \n  // Ergebnisse für jedes Modell berechnen\n  const results = {};\n  for (const model of models_to_evaluate) {\n    try {\n      const modelInfo = modelDb[model];\n      if (!modelInfo) {\n        results[model] = { error: `Unbekanntes Modell: ${model}` };\n        continue;\n      }\n      \n      // Prüfe, ob das Modell die grundlegenden Anforderungen erfüllt\n      const complexityInfo = complexityCategories[task_complexity];\n      if (modelInfo.complexityHandling < complexityInfo.minComplexityHandling) {\n        results[model] = { \n          isRejected: true, \n          rejectionReason: `Modell kann die erforderliche Komplexität nicht bewältigen (${task_complexity})`\n        };\n        continue;\n      }\n      \n      // Berechne die spezifischen Kosten je nach Modelltyp\n      if (modelInfo.type === 'cloud') {\n        results[model] = calculateCloudModelCost(model, inputTokenCount, outputTokenCount);\n      } else {\n        results[model] = calculateLocalModelCost(model, inputTokenCount, outputTokenCount);\n      }\n      \n      // Füge weitere Modellinfos hinzu\n      results[model].modelType = modelInfo.type;\n      results[model].provider = modelInfo.provider || 'local';\n      results[model].qualityScore = modelInfo.qualityScore;\n      results[model].maxContext = modelInfo.maxContext;\n      results[model].multimodalCapable = modelInfo.multimodalCapable;\n    } catch (error) {\n      results[model] = { error: error.message };\n    }\n  }\n  \n  // Finde das kostengünstigste geeignete Modell\n  let cheapestModel = null;\n  let lowestCost = Infinity;\n  \n  for (const model in results) {\n    if (!results[model].isRejected && !results[model].error && results[model].totalCost < lowestCost) {\n      cheapestModel = model;\n      lowestCost = results[model].totalCost;\n    }\n  }\n  \n  // Finde das schnellste geeignete Modell\n  let fastestModel = null;\n  let lowestLatency = Infinity;\n  \n  for (const model in results) {\n    if (!results[model].isRejected && !results[model].error && results[model].latency < lowestLatency) {\n      fastestModel = model;\n      lowestLatency = results[model].latency;\n    }\n  }\n  \n  // Finde das qualitativ beste Modell\n  let bestQualityModel = null;\n  let highestQuality = -Infinity;\n  \n  for (const model in results) {\n    const quality = results[model].qualityScore;\n    if (!results[model].isRejected && !results[model].error && quality > highestQuality) {\n      bestQualityModel = model;\n      highestQuality = quality;\n    }\n  }\n  \n  // Berechne die Gesamtkosten bei Verwendung des Cloud-Modells als Referenz\n  let cloudReferenceModel = \"claude-3-5-sonnet\"; // Standardreferenz\n  const cloudCost = results[cloudReferenceModel] && !results[cloudReferenceModel].isRejected ? \n                   results[cloudReferenceModel].totalCost : \n                   null;\n  \n  // Rückgabe der Ergebnisse\n  return {\n    task: {\n      complexity: task_complexity,\n      complexity_description: complexityCategories[task_complexity].description,\n      input_tokens: inputTokenCount,\n      output_tokens: outputTokenCount,\n      total_tokens: inputTokenCount + outputTokenCount,\n      context_length: effectiveContextLength,\n      multimodal_required: require_multimodal,\n      quality_threshold: quality_threshold\n    },\n    model_results: results,\n    recommendations: {\n      most_cost_effective: cheapestModel ? {\n        model: cheapestModel,\n        cost: results[cheapestModel].totalCost,\n        savings_vs_cloud: cloudCost ? (cloudCost - results[cheapestModel].totalCost) : null,\n        savings_percentage: cloudCost ? ((cloudCost - results[cheapestModel].totalCost) / cloudCost * 100) : null\n      } : null,\n      fastest_response: fastestModel ? {\n        model: fastestModel,\n        latency: results[fastestModel].latency\n      } : null,\n      highest_quality: bestQualityModel ? {\n        model: bestQualityModel,\n        quality_score: results[bestQualityModel].qualityScore\n      } : null\n    },\n    meta: {\n      timestamp: new Date().toISOString(),\n      energy_cost_per_kwh: energy_cost_per_kwh,\n      hardware_amortization_months: hardware_amortization_months,\n      include_hardware_costs: include_hardware_costs\n    }\n  };\n}\n\n// Führe die Kostenschätzung aus\ntry {\n  const estimate = estimateTaskCosts();\n  return estimate;\n} catch (error) {\n  return {\n    error: error.message,\n    timestamp: new Date().toISOString()\n  };\n}"
      },
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [440, 300],
      "id": "calculate-task-costs"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "batch-estimate",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 500],
      "id": "batch-estimate-webhook"
    },
    {
      "parameters": {
        "functionCode": "// Batch-Verarbeitung für mehrere Aufgaben\nconst batchRequest = $input.item.json;\nconst { tasks = [], common_parameters = {} } = batchRequest;\n\n// Importiere die Hauptberechnungsfunktion (als Referenz - in n8n müsste dieser Code dupliziert werden)
const calculateTaskCosts = $node[\"calculate-task-costs\"].function;\n\n// Analysiere den Workflow und berechne die Kosten für jeden Schritt\nfunction estimateWorkflowCosts() {\n  // Validiere die Workflow-Struktur\n  if (!workflow_steps || !Array.isArray(workflow_steps) || workflow_steps.length === 0) {\n    throw new Error(\"Workflow-Struktur ist ungültig oder leer\");\n  }\n  \n  // Topologische Sortierung, um die Workflow-Schritte in Ausführungsreihenfolge zu bringen\n  const sortedSteps = topologicalSort(workflow_steps);\n  \n  // Verarbeite jeden Schritt und berechne die Kosten\n  const stepResults = [];\n  const modelUsageCounts = {};\n  \n  for (const step of sortedSteps) {\n    // Kombiniere step-spezifische Parameter mit gemeinsamen Parametern\n    const stepParameters = { ...common_parameters, ...step.parameters };\n    \n    try {\n      // Führe die Kostenschätzung für diesen Schritt aus\n      const result = calculateTaskCosts(stepParameters);\n      \n      // Wähle das beste Modell basierend auf dem Optimierungsziel\n      let selectedModel, selectedCost, selectedLatency, selectedQuality;\n      \n      if (cost_optimization && result.recommendations.most_cost_effective) {\n        // Kostenoptimierung: Wähle das kostengünstigste Modell\n        selectedModel = result.recommendations.most_cost_effective.model;\n        selectedCost = result.recommendations.most_cost_effective.cost;\n        \n        // Extrahiere Latenz und Qualität des gewählten Modells\n        selectedLatency = result.model_results[selectedModel].latency;\n        selectedQuality = result.model_results[selectedModel].qualityScore;\n      } else if (result.recommendations.fastest_response) {\n        // Geschwindigkeitsoptimierung: Wähle das schnellste Modell\n        selectedModel = result.recommendations.fastest_response.model;\n        selectedLatency = result.model_results[selectedModel].latency;\n        \n        // Extrahiere Kosten und Qualität des gewählten Modells\n        selectedCost = result.model_results[selectedModel].totalCost;\n        selectedQuality = result.model_results[selectedModel].qualityScore;\n      } else if (result.recommendations.highest_quality) {\n        // Qualitätsoptimierung: Wähle das qualitativ beste Modell\n        selectedModel = result.recommendations.highest_quality.model;\n        selectedQuality = result.recommendations.highest_quality.quality_score;\n        \n        // Extrahiere Kosten und Latenz des gewählten Modells\n        selectedCost = result.model_results[selectedModel].totalCost;\n        selectedLatency = result.model_results[selectedModel].latency;\n      } else {\n        throw new Error(\"Keine geeigneten Modelle für diesen Workflow-Schritt gefunden\");\n      }\n      \n      // Zähle die Modellnutzung\n      modelUsageCounts[selectedModel] = (modelUsageCounts[selectedModel] || 0) + 1;\n      \n      // Speichere das Ergebnis für diesen Schritt\n      stepResults.push({\n        step_id: step.id,\n        step_name: step.name || `Schritt ${stepResults.length + 1}`,\n        description: step.description || \"\",\n        complexity: step.parameters?.task_complexity || common_parameters.task_complexity || \"medium\",\n        selected_model: selectedModel,\n        cost: selectedCost,\n        latency: selectedLatency,\n        quality: selectedQuality,\n        token_counts: {\n          input: result.task.input_tokens,\n          output: result.task.output_tokens,\n          total: result.task.total_tokens\n        },\n        full_result: result\n      });\n    } catch (error) {\n      stepResults.push({\n        step_id: step.id,\n        step_name: step.name || `Schritt ${stepResults.length + 1}`,\n        description: step.description || \"\",\n        complexity: step.parameters?.task_complexity || common_parameters.task_complexity || \"medium\",\n        error: error.message\n      });\n    }\n  }\n  \n  // Berechne die kritischen Pfade und die Gesamtkosten\n  const criticalPath = calculateCriticalPath(workflow_steps, stepResults);\n  const totalWorkflowCost = stepResults.reduce((sum, step) => sum + (step.cost || 0), 0);\n  const totalWorkflowTime = criticalPath.totalTime;\n  \n  // Berechne die Kosten für verschiedene Zeiträume\n  const projectedCosts = projectCostsOverTime(\n    totalWorkflowCost, \n    daily_executions, \n    monthly_growth_rate, \n    projection_months\n  );\n  \n  // Rückgabe der Workflow-Ergebnisse mit Zusammenfassung\n  return {\n    workflow_results: {\n      steps: stepResults,\n      critical_path: criticalPath.path,\n      execution_time: totalWorkflowTime,\n      cost_per_execution: totalWorkflowCost\n    },\n    model_usage: Object.entries(modelUsageCounts).map(([model, count]) => ({\n      model,\n      step_count: count,\n      percentage: (count / stepResults.length) * 100\n    })),\n    cost_projections: projectedCosts,\n    summary: {\n      total_steps: stepResults.length,\n      successful_estimates: stepResults.filter(r => !r.error).length,\n      failed_estimates: stepResults.filter(r => r.error).length,\n      cost_per_execution: totalWorkflowCost,\n      daily_cost: totalWorkflowCost * daily_executions,\n      monthly_cost: totalWorkflowCost * daily_executions * 30,\n      annual_cost: totalWorkflowCost * daily_executions * 365,\n      projected_annual_cost_with_growth: projectedCosts.annual,\n      execution_time_seconds: totalWorkflowTime\n    },\n    optimization_strategy: cost_optimization ? \"cost\" : \"performance\",\n    timestamp: new Date().toISOString()\n  };\n}\n\n// Topologische Sortierung der Workflow-Schritte\nfunction topologicalSort(steps) {\n  // Erstelle eine Kopie der Schritte, um die Originaldaten nicht zu verändern\n  const nodesCopy = JSON.parse(JSON.stringify(steps));\n  \n  // Erstelle die Abhängigkeitsgraphen\n  const graph = {};\n  const inDegree = {};\n  \n  // Initialisiere Graphen\n  for (const node of nodesCopy) {\n    graph[node.id] = [];\n    inDegree[node.id] = 0;\n  }\n  \n  // Fülle die Graphen mit Abhängigkeiten\n  for (const node of nodesCopy) {\n    if (node.dependencies && Array.isArray(node.dependencies)) {\n      for (const depId of node.dependencies) {\n        if (graph[depId]) {\n          graph[depId].push(node.id);\n          inDegree[node.id] = (inDegree[node.id] || 0) + 1;\n        }\n      }\n    }\n  }\n  \n  // Kahn's Algorithmus für topologische Sortierung\n  const queue = [];\n  for (const nodeId in inDegree) {\n    if (inDegree[nodeId] === 0) {\n      queue.push(nodeId);\n    }\n  }\n  \n  const result = [];\n  while (queue.length > 0) {\n    const nodeId = queue.shift();\n    const node = nodesCopy.find(n => n.id === nodeId);\n    if (node) {\n      result.push(node);\n    }\n    \n    for (const neighbor of graph[nodeId]) {\n      inDegree[neighbor]--;\n      if (inDegree[neighbor] === 0) {\n        queue.push(neighbor);\n      }\n    }\n  }\n  \n  // Prüfe auf Zyklen im Graphen\n  if (result.length !== nodesCopy.length) {\n    throw new Error(\"Der Workflow enthält Zyklen und kann nicht sortiert werden\");\n  }\n  \n  return result;\n}\n\n// Berechnung des kritischen Pfades im Workflow\nfunction calculateCriticalPath(steps, results) {\n  // Erstelle eine Map der Schrittergebnisse nach ID\n  const resultMap = {};\n  for (const result of results) {\n    if (!result.error) {\n      resultMap[result.step_id] = result;\n    }\n  }\n  \n  // Erstelle den Abhängigkeitsgraphen\n  const graph = {};\n  for (const step of steps) {\n    graph[step.id] = step.dependencies || [];\n  }\n  \n  // Berechne den frühesten Start- und Endzeitpunkt für jeden Schritt\n  const earliestStart = {};\n  const earliestFinish = {};\n  \n  // Initialisiere alle Schritte mit einem frühesten Start von 0\n  for (const step of steps) {\n    earliestStart[step.id] = 0;\n    earliestFinish[step.id] = 0;\n  }\n  \n  // Topologisch sortierte Schritte verwenden, um Vorwärtsdurchlauf zu machen\n  const sortedSteps = topologicalSort(steps);\n  \n  for (const step of sortedSteps) {\n    if (step.dependencies && step.dependencies.length > 0) {\n      // Finde den spätesten Endzeitpunkt aller Vorgänger\n      let maxPredecessorFinish = 0;\n      for (const predId of step.dependencies) {\n        if (earliestFinish[predId] > maxPredecessorFinish) {\n          maxPredecessorFinish = earliestFinish[predId];\n        }\n      }\n      earliestStart[step.id] = maxPredecessorFinish;\n    }\n    \n    // Berechne den frühesten Endzeitpunkt basierend auf der Verarbeitungszeit\n    if (resultMap[step.id]) {\n      earliestFinish[step.id] = earliestStart[step.id] + (resultMap[step.id].latency || 0);\n    } else {\n      // Fallback für Schritte ohne Ergebnis\n      earliestFinish[step.id] = earliestStart[step.id];\n    }\n  }\n  \n  // Finde den spätesten Endzeitpunkt (Projektende)\n  let projectEnd = 0;\n  for (const stepId in earliestFinish) {\n    if (earliestFinish[stepId] > projectEnd) {\n      projectEnd = earliestFinish[stepId];\n    }\n  }\n  \n  // Berechne den spätesten Start- und Endzeitpunkt für jeden Schritt\n  const latestStart = {};\n  const latestFinish = {};\n  \n  // Initialisiere alle Schritte mit einem spätesten Ende von Projektende\n  for (const step of steps) {\n    latestFinish[step.id] = projectEnd;\n    latestStart[step.id] = projectEnd;\n  }\n  \n  // Rückwärtsdurchlauf durch den Graphen\n  for (const step of sortedSteps.slice().reverse()) {\n    if (graph[step.id].length > 0) {\n      // Finde den frühesten Startzeitpunkt aller Nachfolger\n      let minSuccessorStart = projectEnd;\n      for (const succId of graph[step.id]) {\n        if (latestStart[succId] < minSuccessorStart) {\n          minSuccessorStart = latestStart[succId];\n        }\n      }\n      latestFinish[step.id] = minSuccessorStart;\n    } else {\n      // Für Schritte ohne Nachfolger ist der späteste Endzeitpunkt gleich dem Projektende\n      latestFinish[step.id] = projectEnd;\n    }\n    \n    // Berechne den spätesten Startzeitpunkt basierend auf der Verarbeitungszeit\n    if (resultMap[step.id]) {\n      latestStart[step.id] = latestFinish[step.id] - (resultMap[step.id].latency || 0);\n    } else {\n      // Fallback für Schritte ohne Ergebnis\n      latestStart[step.id] = latestFinish[step.id];\n    }\n  }\n  \n  // Berechne den Puffer für jeden Schritt und identifiziere kritische Schritte\n  const slack = {};\n  const criticalSteps = [];\n  \n  for (const step of steps) {\n    slack[step.id] = latestStart[step.id] - earliestStart[step.id];\n    if (slack[step.id] === 0) {\n      criticalSteps.push(step.id);\n    }\n  }\n  \n  // Erstelle den kritischen Pfad\n  const criticalPath = [];\n  for (const stepId of criticalSteps) {\n    const step = steps.find(s => s.id === stepId);\n    if (step && resultMap[stepId]) {\n      criticalPath.push({\n        step_id: stepId,\n        step_name: step.name || stepId,\n        start_time: earliestStart[stepId],\n        end_time: earliestFinish[stepId],\n        duration: resultMap[stepId].latency || 0\n      });\n    }\n  }\n  \n  // Sortiere den kritischen Pfad nach Startzeit\n  criticalPath.sort((a, b) => a.start_time - b.start_time);\n  \n  return {\n    path: criticalPath,\n    totalTime: projectEnd\n  };\n}\n\n// Projektion der Kosten über die Zeit\nfunction projectCostsOverTime(baseCost, dailyExecutions, monthlyGrowthRate, months) {\n  const projections = {\n    monthly: [],\n    quarterly: [],\n    annual: 0\n  };\n  \n  let currentDailyExecutions = dailyExecutions;\n  let totalAnnualCost = 0;\n  \n  for (let month = 1; month <= months; month++) {\n    // Berechne die monatlichen Kosten\n    const monthlyCost = baseCost * currentDailyExecutions * 30;\n    \n    // Füge zur monatlichen Projektion hinzu\n    projections.monthly.push({\n      month,\n      executions_per_day: currentDailyExecutions,\n      cost: monthlyCost\n    });\n    \n    // Füge zur vierteljährlichen Projektion hinzu, falls ein Quartal abgeschlossen ist\n    if (month % 3 === 0) {\n      const quarterlyData = {\n        quarter: Math.floor(month / 3),\n        months: [(month - 2), (month - 1), month],\n        cost: projections.monthly.slice(-3).reduce((sum, m) => sum + m.cost, 0)\n      };\n      projections.quarterly.push(quarterlyData);\n    }\n    \n    // Summiere die jährlichen Kosten\n    totalAnnualCost += monthlyCost;\n    \n    // Aktualisiere die täglichen Ausführungen basierend auf der Wachstumsrate\n    currentDailyExecutions *= (1 + (monthlyGrowthRate / 100));\n  }\n  \n  // Speichere die Gesamtjahreskosten\n  projections.annual = totalAnnualCost;\n  \n  return projections;\n}\n\n// Führe die Workflow-Kostenschätzung aus\ntry {\n  const workflowEstimate = estimateWorkflowCosts();\n  return workflowEstimate;\n} catch (error) {\n  return {\n    error: error.message,\n    timestamp: new Date().toISOString()\n  };\n}"
      },
echnungsfunktion (als Referenz - in n8n müsste dieser Code dupliziert werden)\nconst calculateTaskCosts = $node[\"calculate-task-costs\"].function;\n\n// Verarbeite jede Aufgabe in der Gruppe\nconst batchResults = [];\n\nfor (const task of tasks) {\n  // Kombiniere aufgabenspezifische Parameter mit gemeinsamen Parametern\n  const combinedParameters = { ...common_parameters, ...task };\n  \n  try {\n    // Führe die Kostenschätzung für diese Aufgabe aus\n    const result = calculateTaskCosts(combinedParameters);\n    batchResults.push({\n      task_id: task.task_id || `Task-${batchResults.length + 1}`,\n      task_description: task.description || `Aufgabe ${batchResults.length + 1}`,\n      complexity: task.task_complexity || common_parameters.task_complexity || \"medium\",\n      result: result\n    });\n  } catch (error) {\n    batchResults.push({\n      task_id: task.task_id || `Task-${batchResults.length + 1}`,\n      task_description: task.description || `Aufgabe ${batchResults.length + 1}`,\n      complexity: task.task_complexity || common_parameters.task_complexity || \"medium\",\n      error: error.message\n    });\n  }\n}\n\n// Berechne die Gesamtkosten\nlet totalCloudCost = 0;\nlet totalLocalCost = 0;\nlet totalSavings = 0;\n\nfor (const result of batchResults) {\n  if (result.result && result.result.recommendations && result.result.recommendations.most_cost_effective) {\n    const recommendation = result.result.recommendations.most_cost_effective;\n    \n    // Kostengünstigstes Modell\n    const bestModelCost = recommendation.cost || 0;\n    \n    // Cloud-Referenzkosten\n    const cloudCost = recommendation.savings_vs_cloud !== null ? \n                      bestModelCost + recommendation.savings_vs_cloud : \n                      bestModelCost; // Fallback, falls keine Ersparnisse berechnet wurden\n    \n    // Summieren\n    if (result.result.model_results[recommendation.model].modelType === 'cloud') {\n      totalCloudCost += bestModelCost;\n    } else {\n      totalLocalCost += bestModelCost;\n    }\n    \n    // Ersparnisse\n    totalSavings += (recommendation.savings_vs_cloud || 0);\n  }\n}\n\n// Rückgabe der Batch-Ergebnisse mit Zusammenfassung\nreturn {\n  batch_results: batchResults,\n  summary: {\n    total_tasks: batchResults.length,\n    successful_estimates: batchResults.filter(r => !r.error).length,\n    failed_estimates: batchResults.filter(r => r.error).length,\n    total_cloud_cost: totalCloudCost,\n    total_local_cost: totalLocalCost,\n    total_cost: totalCloudCost + totalLocalCost,\n    total_savings_vs_all_cloud: totalSavings,\n    savings_percentage: totalSavings > 0 ? (totalSavings / (totalCloudCost + totalLocalCost + totalSavings) * 100) : 0\n  },\n  timestamp: new Date().toISOString()\n};"
      },
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [440, 500],
      "id": "process-batch-estimates"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "workflow-cost-estimate",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 700],
      "id": "workflow-cost-webhook"
    },
    {
      "parameters": {
        "functionCode": "// Workflow-Kosten-Schätzung für komplette Prozess-Workflows\nconst workflowRequest = $input.item.json;\n\n// Extrahiere Parameter mit Defaults\nconst {\n  workflow_steps = [],           // Array von Workflow-Schritten mit Abhängigkeiten\n  common_parameters = {},       // Gemeinsame Parameter für alle Schritte\n  daily_executions = 1,         // Tägliche Ausführungen\n  monthly_growth_rate = 0,      // Monatliche Wachstumsrate in Prozent\n  projection_months = 12,       // Anzahl der Monate für die Projektion\n  cost_optimization = true      // Ob Kosten optimiert werden sollen\n} = workflowRequest;\n\n// Importiere die Hauptberconst stepId in earliestFinish) {\n    if (earliestFinish[stepId] > projectEnd) {\n      projectEnd = earliestFinish[stepId];\n    }\n  }\n  \n  // Berechne den spätesten Start- und Endzeitpunkt für jeden Schritt\n  const latestStart = {};\n  const latestFinish = {};\n  \n  // Initialisiere alle Schritte mit einem spätesten Ende von Projektende\n  for (const step of steps) {\n    latestFinish[step.id] = projectEnd;\n    latestStart[step.id] = projectEnd;\n  }\n  \n  // Rückwärtsdurchlauf durch den Graphen\n  for (const step of sortedSteps.slice().reverse()) {\n    if (graph[step.id].length > 0) {\n      // Finde den frühesten Startzeitpunkt aller Nachfolger\n      let minSuccessorStart = projectEnd;\n      for (const succId of graph[step.id]) {\n        if (latestStart[succId] < minSuccessorStart) {\n          minSuccessorStart = latestStart[succId];\n        }\n      }\n      latestFinish[step.id] = minSuccessorStart;\n    } else {\n      // Für Schritte ohne Nachfolger ist der späteste Endzeitpunkt gleich dem Projektende\n      latestFinish[step.id] = projectEnd;\n    }\n    \n    // Berechne den spätesten Startzeitpunkt basierend auf der Verarbeitungszeit\n    if (resultMap[step.id]) {\n      latestStart[step.id] = latestFinish[step.id] - (resultMap[step.id].latency || 0);\n    } else {\n      // Fallback für Schritte ohne Ergebnis\n      latestStart[step.id] = latestFinish[step.id];\n    }\n  }\n  \n  // Berechne den Puffer für jeden Schritt und identifiziere kritische Schritte\n  const slack = {};\n  const criticalSteps = [];\n  \n  for (const step of steps) {\n    slack[step.id] = latestStart[step.id] - earliestStart[step.id];\n    if (slack[step.id] === 0) {\n      criticalSteps.push(step.id);\n    }\n  }\n  \n  // Erstelle den kritischen Pfad\n  const criticalPath = [];\n  for (const stepId of criticalSteps) {\n    const step = steps.find(s => s.id === stepId);\n    if (step && resultMap[stepId]) {\n      criticalPath.push({\n        step_id: stepId,\n        step_name: step.name || stepId,\n        start_time: earliestStart[stepId],\n        end_time: earliestFinish[stepId],\n        duration: resultMap[stepId].latency || 0\n      });\n    }\n  }\n  \n  // Sortiere den kritischen Pfad nach Startzeit\n  criticalPath.sort((a, b) => a.start_time - b.start_time);\n  \n  return {\n    path: criticalPath,\n    totalTime: projectEnd\n  };\n}\n\n// Projektion der Kosten über die Zeit\nfunction projectCostsOverTime(baseCost, dailyExecutions, monthlyGrowthRate, months) {\n  const projections = {\n    monthly: [],\n    quarterly: [],\n    annual: 0\n  };\n  \n  let currentDailyExecutions = dailyExecutions;\n  let totalAnnualCost = 0;\n  \n  for (let month = 1; month <= months; month++) {\n    // Berechne die monatlichen Kosten\n    const monthlyCost = baseCost * currentDailyExecutions * 30;\n    \n    // Füge zur monatlichen Projektion hinzu\n    projections.monthly.push({\n      month,\n      executions_per_day: currentDailyExecutions,\n      cost: monthlyCost\n    });\n    \n    // Füge zur vierteljährlichen Projektion hinzu, falls ein Quartal abgeschlossen ist\n    if (month % 3 === 0) {\n      const quarterlyData = {\n        quarter: Math.floor(month / 3),\n        months: [(month - 2), (month - 1), month],\n        cost: projections.monthly.slice(-3).reduce((sum, m) => sum + m.cost, 0)\n      };\n      projections.quarterly.push(quarterlyData);\n    }\n    \n    // Summiere die jährlichen Kosten\n    totalAnnualCost += monthlyCost;\n    \n    // Aktualisiere die täglichen Ausführungen basierend auf der Wachstumsrate\n    currentDailyExecutions *= (1 + (monthlyGrowthRate / 100));\n  }\n  \n  // Speichere die Gesamtjahreskosten\n  projections.annual = totalAnnualCost;\n  \n  return projections;\n}\n\n// Führe die Workflow-Kostenschätzung aus\ntry {\n  const workflowEstimate = estimateWorkflowCosts();\n  return workflowEstimate;\n} catch (error) {\n  return {\n    error: error.message,\n    timestamp: new Date().toISOString()\n  };\n}"
      },
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [440, 700],
      "id": "calculate-workflow-costs"
    },
    {
      "parameters": {
        "httpMethod": "GET",
        "path": "complexity-categories",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 900],
      "id": "complexity-categories-webhook"
    },
    {
      "parameters": {
        "functionCode": "// Gibt die verfügbaren Komplexitätskategorien mit ihren Beschreibungen zurück\n\n// Definition der Komplexitätskategorien\nconst complexityCategories = {\n  \"very_simple\": {\n    description: \"Sehr einfache Aufgaben: Klassifikation, kurze Antworten, einfache Fragen\",\n    avgInputTokens: 200,\n    avgOutputTokens: 100,\n    minComplexityHandling: 4.0,\n    requiredContextSize: 1024,\n    processingTimeMultiplier: 1.0,\n    examples: [\n      \"Ist dieser Text positiv oder negativ?\",\n      \"Was ist die Hauptstadt von Frankreich?\",\n      \"Konvertiere 10 USD in EUR\"\n    ]\n  },\n  \"simple\": {\n    description: \"Einfache Aufgaben: Zusammenfassungen, kurze Texte, einfache Faktenrecherche\",\n    avgInputTokens: 1000,\n    avgOutputTokens: 300,\n    minComplexityHandling: 5.0,\n    requiredContextSize: 2048,\n    processingTimeMultiplier: 1.2,\n    examples: [\n      \"Fasse diesen Artikel in drei Sätzen zusammen\",\n      \"Erkläre das Konzept der Photosynthese\",\n      \"Wie funktioniert ein Elektromotor?\"\n    ]\n  },\n  \"medium\": {\n    description: \"Mittlere Komplexität: Standard-Codegeneration, detaillierte Antworten, Analysen\",\n    avgInputTokens: 2000,\n    avgOutputTokens: 800,\n    minComplexityHandling: 6.5,\n    requiredContextSize: 4096,\n    processingTimeMultiplier: 1.5,\n    examples: [\n      \"Schreibe eine Python-Funktion zur Berechnung der Fibonacci-Folge\",\n      \"Analysiere die wichtigsten Faktoren des Klimawandels\",\n      \"Vergleiche die Vor- und Nachteile von REST und GraphQL\"\n    ]\n  },\n  \"complex\": {\n    description: \"Komplexe Aufgaben: Tiefe Textanalysen, fortgeschrittene Codegeneration, logisches Reasoning\",\n    avgInputTokens: 4000,\n    avgOutputTokens: 1500,\n    minComplexityHandling: 7.5,\n    requiredContextSize: 8192,\n    processingTimeMultiplier: 2.0,\n    examples: [\n      \"Implementiere einen effizienten Algorithmus zur Pfadfindung in einem Graphen\",\n      \"Analysiere die Marktchancen für ein neues Produkt in der Biotechnologie\",\n      \"Entwickle einen modularen Workflow für die Integration von mehreren APIs\"\n    ]\n  },\n  \"very_complex\": {\n    description: \"Sehr komplexe Aufgaben: Multi-step Reasoning, detaillierte Berichte, komplexe Problemlösung\",\n    avgInputTokens: 8000,\n    avgOutputTokens: 3000,\n    minComplexityHandling: 8.5,\n    requiredContextSize: 16384,\n    processingTimeMultiplier: 3.0,\n    examples: [\n      \"Erstelle eine detaillierte Kostenanalyse für ein Softwareprojekt mit mehreren Komponenten\",\n      \"Entwickle eine vollständige Architektur für ein verteiltes System\",\n      \"Analysiere einen wissenschaftlichen Artikel und finde methodische Schwächen\"\n    ]\n  },\n  \"extremely_complex\": {\n    description: \"Extrem komplexe Aufgaben: Forschungssynthesen, hochkomplexe Logikketten, AI-Agenten-Systeme\",\n    avgInputTokens: 15000,\n    avgOutputTokens: 4000,\n    minComplexityHandling: 9.5,\n    requiredContextSize: 32768,\n    processingTimeMultiplier: 4.0,\n    examples: [\n      \"Entwickle einen vollständigen Forschungsüberblick über den aktuellen Stand der Quantencomputer\",\n      \"Erstelle ein System von kooperierenden AI-Agenten mit unterschiedlichen Spezialisierungen\",\n      \"Implementiere ein komplexes Simulationsmodell für Klimaprognosen\"\n    ]\n  }\n};\n\n// Formatiere die Ausgabe für eine bessere Benutzerfreundlichkeit\nconst formattedCategories = {};\n\nfor (const [category, info] of Object.entries(complexityCategories)) {\n  formattedCategories[category] = {\n    description: info.description,\n    average_tokens: {\n      input: info.avgInputTokens,\n      output: info.avgOutputTokens,\n      total: info.avgInputTokens + info.avgOutputTokens\n    },\n    minimum_requirements: {\n      model_capability: info.minComplexityHandling,\n      context_length: info.requiredContextSize\n    },\n    processing_time_factor: info.processingTimeMultiplier,\n    examples: info.examples\n  };\n}\n\nreturn {\n  complexity_categories: formattedCategories,\n  usage_tips: {\n    selecting_complexity: \"Wählen Sie die Komplexitätskategorie basierend auf der Art der Aufgabe und der erwarteten Tokenanzahl.\",\n    custom_tokens: \"Wenn Sie die genaue Token-Anzahl kennen, können Sie diese direkt angeben, anstatt eine Komplexitätskategorie zu verwenden.\",\n    context_length: \"Beachten Sie, dass komplexere Aufgaben in der Regel längere Kontextfenster benötigen.\"\n  }\n};"
      },
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [440, 900],
      "id": "get-complexity-categories"
    },
    {
      "parameters": {
        "httpMethod": "GET",
        "path": "available-models",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 1100],
      "id": "available-models-webhook"
    },
    {
      "parameters": {
        "functionCode": "// Gibt die verfügbaren LLM-Modelle mit ihren Spezifikationen zurück\n\n// Modell-Datenbank mit Kosten und Funktionen\nconst modelDb = {\n  // Cloud-Modelle\n  \"claude-3-5-sonnet\": {\n    \"type\": \"cloud\",\n    \"provider\": \"anthropic\",\n    \"inputCost\": 3.0,     // € pro 1M Tokens\n    \"outputCost\": 15.0,   // € pro 1M Tokens\n    \"maxContext\": 200000,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 150,  // Tokens pro Sekunde\n    \"complexityHandling\": 9.5,    // 1-10 Skala\n    \"qualityScore\": 9.5,          // 1-10 Skala\n    \"multimodalCapable\": true\n  },\n  \"claude-3-opus\": {\n    \"type\": \"cloud\",\n    \"provider\": \"anthropic\",\n    \"inputCost\": 15.0,\n    \"outputCost\": 75.0,\n    \"maxContext\": 200000,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 100,\n    \"complexityHandling\": 10.0,\n    \"qualityScore\": 10.0,\n    \"multimodalCapable\": true\n  },\n  \"gpt-4o\": {\n    \"type\": \"cloud\",\n    \"provider\": \"openai\",\n    \"inputCost\": 10.0,\n    \"outputCost\": 30.0,\n    \"maxContext\": 128000,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 120,\n    \"complexityHandling\": 9.5,\n    \"qualityScore\": 9.5,\n    \"multimodalCapable\": true\n  },\n  \"gpt-4o-mini\": {\n    \"type\": \"cloud\",\n    \"provider\": \"openai\",\n    \"inputCost\": 5.0,\n    \"outputCost\": 15.0,\n    \"maxContext\": 128000,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 150,\n    \"complexityHandling\": 9.0,\n    \"qualityScore\": 8.8,\n    \"multimodalCapable\": true\n  },\n  \n  // Lokale Modelle\n  \"local-1.5b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 1500,          // Anschaffungskosten in €\n    \"powerConsumptionW\": 150,      // Watt\n    \"maxContext\": 2048,\n    \"maxOutput\": 2048,\n    \"tokenProcessingSpeed\": 100,    // Tokens pro Sekunde\n    \"complexityHandling\": 4.5,      // 1-10 Skala\n    \"qualityScore\": 5.0,            // 1-10 Skala\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 50\n  },\n  \"local-3b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 2000,\n    \"powerConsumptionW\": 200,\n    \"maxContext\": 4096,\n    \"maxOutput\": 2048,\n    \"tokenProcessingSpeed\": 80,\n    \"complexityHandling\": 5.5,\n    \"qualityScore\": 6.0,\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 75\n  },\n  \"local-7b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 2500,\n    \"powerConsumptionW\": 300,\n    \"maxContext\": 8192,\n    \"maxOutput\": 2048,\n    \"tokenProcessingSpeed\": 50,\n    \"complexityHandling\": 7.0,\n    \"qualityScore\": 7.5,\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 100\n  },\n  \"local-13b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 3000,\n    \"powerConsumptionW\": 400,\n    \"maxContext\": 8192,\n    \"maxOutput\": 2048,\n    \"tokenProcessingSpeed\": 30,\n    \"complexityHandling\": 7.5,\n    \"qualityScore\": 8.0,\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 125\n  },\n  \"local-34b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 7500,\n    \"powerConsumptionW\": 800,\n    \"maxContext\": 16384,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 15,\n    \"complexityHandling\": 8.5,\n    \"qualityScore\": 8.8,\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 200\n  },\n  \"local-70b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 15000,\n    \"powerConsumptionW\": 1200,\n    \"maxContext\": 32768,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 8,\n    \"complexityHandling\": 9.0,\n    \"qualityScore\": 9.2,\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 300\n  }\n};\n\n// Gruppiere Modelle nach Typ\nconst cloudModels = [];\nconst localModels = [];\n\nfor (const [modelId, modelInfo] of Object.entries(modelDb)) {\n  const modelData = {\n    id: modelId,\n    ...modelInfo\n  };\n  \n  if (modelInfo.type === 'cloud') {\n    cloudModels.push(modelData);\n  } else {\n    localModels.push(modelData);\n  }\n}\n\n// Sortiere nach Komplexitätshandhabung (aufsteigend)\ncloudModels.sort((a, b) => a.complexityHandling - b.complexityHandling);\nlocalModels.sort((a, b) => a.complexityHandling - b.complexityHandling);\n\n// Rückgabe der formatierten Modellinfos\nreturn {\n  cloud_models: cloudModels,\n  local_models: localModels,\n  model_capabilities: {\n    quality_scale: \"Qualitätswerte liegen auf einer Skala von 1 (niedrig) bis 10 (ausgezeichnet)\",\n    complexity_scale: \"Komplexitätshandhabung liegt auf einer Skala von 1 (einfach) bis 10 (hochkomplex)\",\n    context_length_explanation: \"Die maximale Kontextlänge gibt an, wie viele Tokens das Modell verarbeiten kann\"\n  },\n  pricing_notes: {\n    cloud_models: \"Cloud-Modellkosten werden pro Million Token berechnet, getrennt für Input und Output\",\n    local_models: \"Für lokale Modelle fallen einmalige Hardware-Kosten sowie Strom- und Wartungskosten an\"\n  }\n};"
      },
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [440, 1100],
      "id": "get-available-models"
    },
    {
      "parameters": {
        "functionCode": "// Generiert visuelle Darstellungen der Kostenschätzungen\n\n// Diese Funktion würde in einer realen Implementierung Visualisierungen erstellen\n// Hier ist eine Platzhalterfunktion, die JSON-Daten für ein Chart.js-Diagramm generiert\n\nfunction generateChartConfig(data, type = 'bar') {\n  // Standardkonfiguration für Chart.js\n  const config = {\n    type: type,\n    data: {\n      labels: [],\n      datasets: []\n    },\n    options: {\n      responsive: true,\n      plugins: {\n        title: {\n          display: true,\n          text: ''\n        },\n        tooltip: {\n          callbacks: {}\n        }\n      }\n    }\n  };\n  \n  // Konfiguration je nach Datentyp anpassen\n  if (data.model_results) {\n    // Für einzelne Task-Kosten\n    config.options.plugins.title.text = 'Kostenvergleich nach Modell';\n    \n    const modelNames = Object.keys(data.model_results);\n    const costs = [];\n    const latencies = [];\n    const qualityScores = [];\n    const backgroundColors = [];\n    \n    for (const model of modelNames) {\n      const modelData = data.model_results[model];\n      if (!modelData.isRejected && !modelData.error) {\n        costs.push(modelData.totalCost);\n        latencies.push(modelData.latency);\n        qualityScores.push(modelData.qualityScore * 10); // Skalierung für bessere Sichtbarkeit\n        \n        // Farben nach Modelltyp\n        if (modelData.modelType === 'cloud') {\n          backgroundColors.push('rgba(54, 162, 235, 0.6)');\n        } else {\n          backgroundColors.push('rgba(75, 192, 192, 0.6)');\n        }\n      }\n    }\n    \n    config.data.labels = modelNames.filter((_, i) => costs[i] !== undefined);\n    config.data.datasets = [\n      {\n        label: 'Kosten (€)',\n        data: costs,\n        backgroundColor: backgroundColors,\n        yAxisID: 'y'\n      },\n      {\n        label: 'Latenz (s)',\n        data: latencies,\n        backgroundColor: 'rgba(255, 99, 132, 0.6)',\n        yAxisID: 'y1'\n      },\n      {\n        label: 'Qualität (x10)',\n        data: qualityScores,\n        backgroundColor: 'rgba(255, 206, 86, 0.6)',\n        yAxisID: 'y2'\n      }\n    ];\n    \n    config.options.scales = {\n      y: {\n        type: 'linear',\n        display: true,\n        position: 'left',\n        title: {\n          display: true,\n          text: 'Kosten (€)'\n        }\n      },\n      y1: {\n        type: 'linear',\n        display: true,\n        position: 'right',\n        title: {\n          display: true,\n          text: 'Latenz (s)'\n        },\n        grid: {\n          drawOnChartArea: false\n        }\n      },\n      y2: {\n        type: 'linear',\n        display: true,\n        position: 'right',\n        title: {\n          display: true,\n          text: 'Qualität'\n        },\n        grid: {\n          drawOnChartArea: false\n        }\n      }\n    };\n  } else if (data.cost_projections && data.cost_projections.monthly) {\n    // Für Kostenprognosen\n    config.type = 'line';\n    config.options.plugins.title.text = 'Kostenprognose über Zeit';\n    \n    const months = data.cost_projections.monthly.map(m => `Monat ${m.month}`);\n    const costs = data.cost_projections.monthly.map(m => m.cost);\n    \n    config.data.labels = months;\n    config.data.datasets = [\n      {\n        label: 'Monatliche Kosten (€)',\n        data: costs,\n        borderColor: 'rgba(75, 192, 192, 1)',\n        backgroundColor: 'rgba(75, 192, 192, 0.2)',\n        tension: 0.1,\n        fill: true\n      }\n    ];\n  } else if (data.workflow_results && data.workflow_results.steps) {\n    // Für Workflow-Kosten\n    config.options.plugins.title.text = 'Kostenverteilung im Workflow';\n    \n    const stepNames = data.workflow_results.steps\n      .filter(step => !step.error)\n      .map(step => step.step_name);\n      \n    const stepCosts = data.workflow_results.steps\n      .filter(step => !step.error)\n      .map(step => step.cost);\n      \n    const stepLatencies = data.workflow_results.steps\n      .filter(step => !step.error)\n      .map(step => step.latency);\n    \n    config.data.labels = stepNames;\n    config.data.datasets = [\n      {\n        label: 'Kosten pro Schritt (€)',\n        data: stepCosts,\n        backgroundColor: 'rgba(75, 192, 192, 0.6)'\n      }\n    ];\n    \n    // Zweiter Charttyp für die Ausführungszeit\n    const latencyChartConfig = JSON.parse(JSON.stringify(config));\n    latencyChartConfig.options.plugins.title.text = 'Ausführungszeit im Workflow';\n    latencyChartConfig.data.datasets = [\n      {\n        label: 'Latenz pro Schritt (s)',\n        data: stepLatencies,\n        backgroundColor: 'rgba(255, 99, 132, 0.6)'\n      }\n    ];\n    \n    return [config, latencyChartConfig];\n  }\n  \n  return config;\n}\n\n// Verarbeite die Daten und generiere die entsprechenden Visualisierungen\nfunction generateVisualizations(data) {\n  // Prüfe den Datentyp und generiere entsprechende Visualisierungen\n  if (data.task && data.model_results) {\n    // Einzelne Task-Kostenschätzung\n    return {\n      cost_comparison_chart: generateChartConfig(data, 'bar'),\n      recommendations: {\n        most_cost_effective: data.recommendations.most_cost_effective,\n        fastest_response: data.recommendations.fastest_response,\n        highest_quality: data.recommendations.highest_quality\n      }\n    };\n  } else if (data.batch_results) {\n    // Batch-Verarbeitung mehrerer Aufgaben\n    return {\n      batch_summary_chart: generateChartConfig({\n        cost_projections: {\n          monthly: data.batch_results.map((result, index) => ({\n            month: index + 1,\n            cost: result.result?.recommendations?.most_cost_effective?.cost || 0\n          }))\n        }\n      }, 'line'),\n      task_comparison: {\n        labels: data.batch_results.map(result => result.task_id || result.task_description),\n        costs: data.batch_results.map(result => result.result?.recommendations?.most_cost_effective?.cost || 0)\n      }\n    };\n  } else if (data.workflow_results) {\n    // Workflow-Kostenschätzung\n    const charts = generateChartConfig(data, 'bar');\n    return {\n      workflow_cost_chart: charts[0],\n      workflow_latency_chart: charts[1],\n      critical_path_visualization: {\n        steps: data.workflow_results.critical_path.map(step => ({\n          id: step.step_id,\n          name: step.step_name,\n          start: step.start_time,\n          end: step.end_time,\n          duration: step.duration\n        }))\n      }\n    };\n  }\n  \n  // Fallback für unbekannte Datentypen\n  return {\n    error: \"Keine passende Visualisierung für diesen Datentyp verfügbar\"\n  };\n}\n\n// Beispielaufruf mit Demo-Daten\nconst demoData = {\n  task: {\n    complexity: \"medium\",\n    input_tokens: 2000,\n    output_tokens: 800\n  },\n  model_results: {\n    \"claude-3-5-sonnet\": {\n      totalCost: 0.042,\n      latency: 18.7,\n      qual{
  "name": "Task-Cost-Estimation",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "estimate-task-cost",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 300],
      "id": "task-cost-webhook"
    },
    {
      "parameters": {
        "functionCode": "// Hauptfunktion zur Schätzung der Kosten basierend auf Aufgabenkomplexität\nconst taskRequest = $input.item.json;\n\n// Modell-Datenbank mit Kosten und Funktionen\nconst modelDb = {\n  // Cloud-Modelle\n  \"claude-3-5-sonnet\": {\n    \"type\": \"cloud\",\n    \"provider\": \"anthropic\",\n    \"inputCost\": 3.0,     // € pro 1M Tokens\n    \"outputCost\": 15.0,   // € pro 1M Tokens\n    \"maxContext\": 200000,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 150,  // Tokens pro Sekunde\n    \"complexityHandling\": 9.5,    // 1-10 Skala\n    \"qualityScore\": 9.5,          // 1-10 Skala\n    \"multimodalCapable\": true\n  },\n  \"claude-3-opus\": {\n    \"type\": \"cloud\",\n    \"provider\": \"anthropic\",\n    \"inputCost\": 15.0,\n    \"outputCost\": 75.0,\n    \"maxContext\": 200000,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 100,\n    \"complexityHandling\": 10.0,\n    \"qualityScore\": 10.0,\n    \"multimodalCapable\": true\n  },\n  \"gpt-4o\": {\n    \"type\": \"cloud\",\n    \"provider\": \"openai\",\n    \"inputCost\": 10.0,\n    \"outputCost\": 30.0,\n    \"maxContext\": 128000,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 120,\n    \"complexityHandling\": 9.5,\n    \"qualityScore\": 9.5,\n    \"multimodalCapable\": true\n  },\n  \"gpt-4o-mini\": {\n    \"type\": \"cloud\",\n    \"provider\": \"openai\",\n    \"inputCost\": 5.0,\n    \"outputCost\": 15.0,\n    \"maxContext\": 128000,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 150,\n    \"complexityHandling\": 9.0,\n    \"qualityScore\": 8.8,\n    \"multimodalCapable\": true\n  },\n  \n  // Lokale Modelle\n  \"local-1.5b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 1500,          // Anschaffungskosten in €\n    \"powerConsumptionW\": 150,      // Watt\n    \"maxContext\": 2048,\n    \"maxOutput\": 2048,\n    \"tokenProcessingSpeed\": 100,    // Tokens pro Sekunde\n    \"complexityHandling\": 4.5,      // 1-10 Skala\n    \"qualityScore\": 5.0,            // 1-10 Skala\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 50\n  },\n  \"local-3b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 2000,\n    \"powerConsumptionW\": 200,\n    \"maxContext\": 4096,\n    \"maxOutput\": 2048,\n    \"tokenProcessingSpeed\": 80,\n    \"complexityHandling\": 5.5,\n    \"qualityScore\": 6.0,\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 75\n  },\n  \"local-7b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 2500,\n    \"powerConsumptionW\": 300,\n    \"maxContext\": 8192,\n    \"maxOutput\": 2048,\n    \"tokenProcessingSpeed\": 50,\n    \"complexityHandling\": 7.0,\n    \"qualityScore\": 7.5,\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 100\n  },\n  \"local-13b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 3000,\n    \"powerConsumptionW\": 400,\n    \"maxContext\": 8192,\n    \"maxOutput\": 2048,\n    \"tokenProcessingSpeed\": 30,\n    \"complexityHandling\": 7.5,\n    \"qualityScore\": 8.0,\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 125\n  },\n  \"local-34b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 7500,\n    \"powerConsumptionW\": 800,\n    \"maxContext\": 16384,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 15,\n    \"complexityHandling\": 8.5,\n    \"qualityScore\": 8.8,\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 200\n  },\n  \"local-70b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 15000,\n    \"powerConsumptionW\": 1200,\n    \"maxContext\": 32768,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 8,\n    \"complexityHandling\": 9.0,\n    \"qualityScore\": 9.2,\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 300\n  }\n};\n\n// Kompexitätskategorien mit typischen Token-Anforderungen\nconst complexityCategories = {\n  \"very_simple\": {\n    description: \"Sehr einfache Aufgaben: Klassifikation, kurze Antworten, einfache Fragen\",\n    avgInputTokens: 200,\n    avgOutputTokens: 100,\n    minComplexityHandling: 4.0,\n    requiredContextSize: 1024,\n    processingTimeMultiplier: 1.0\n  },\n  \"simple\": {\n    description: \"Einfache Aufgaben: Zusammenfassungen, kurze Texte, einfache Faktenrecherche\",\n    avgInputTokens: 1000,\n    avgOutputTokens: 300,\n    minComplexityHandling: 5.0,\n    requiredContextSize: 2048,\n    processingTimeMultiplier: 1.2\n  },\n  \"medium\": {\n    description: \"Mittlere Komplexität: Standard-Codegeneration, detaillierte Antworten, Analysen\",\n    avgInputTokens: 2000,\n    avgOutputTokens: 800,\n    minComplexityHandling: 6.5,\n    requiredContextSize: 4096,\n    processingTimeMultiplier: 1.5\n  },\n  \"complex\": {\n    description: \"Komplexe Aufgaben: Tiefe Textanalysen, fortgeschrittene Codegeneration, logisches Reasoning\",\n    avgInputTokens: 4000,\n    avgOutputTokens: 1500,\n    minComplexityHandling: 7.5,\n    requiredContextSize: 8192,\n    processingTimeMultiplier: 2.0\n  },\n  \"very_complex\": {\n    description: \"Sehr komplexe Aufgaben: Multi-step Reasoning, detaillierte Berichte, komplexe Problemlösung\",\n    avgInputTokens: 8000,\n    avgOutputTokens: 3000,\n    minComplexityHandling: 8.5,\n    requiredContextSize: 16384,\n    processingTimeMultiplier: 3.0\n  },\n  \"extremely_complex\": {\n    description: \"Extrem komplexe Aufgaben: Forschungssynthesen, hochkomplexe Logikketten, AI-Agenten-Systeme\",\n    avgInputTokens: 15000,\n    avgOutputTokens: 4000,\n    minComplexityHandling: 9.5,\n    requiredContextSize: 32768,\n    processingTimeMultiplier: 4.0\n  }\n};\n\n// Parameter aus dem Request extrahieren mit Defaults\nconst {\n  task_complexity = \"medium\",           // very_simple, simple, medium, complex, very_complex, extremely_complex\n  input_tokens,                        // Optional: Explizite Angabe von Eingabe-Tokens\n  output_tokens,                       // Optional: Explizite Angabe von Ausgabe-Tokens\n  context_length,                      // Optional: Explizite Angabe von Kontextlänge\n  models_to_evaluate = Object.keys(modelDb),  // Zu bewertende Modelle\n  require_multimodal = false,          // Multimodale Fähigkeiten erforderlich?\n  quality_threshold = 7.0,             // Mindestqualität (1-10)\n  energy_cost_per_kwh = 0.30,          // Energiekosten pro kWh\n  hardware_amortization_months = 36,   // Abschreibungszeitraum für Hardware in Monaten\n  include_hardware_costs = true,       // Hardware-Kosten einbeziehen?\n  custom_parameters = {}               // Zusätzliche benutzerdefinierte Parameter\n} = taskRequest;\n\n// Funktion zur Berechnung der Tokenisierungskosten für Cloud-Modelle\nfunction calculateCloudModelCost(model, inputTokenCount, outputTokenCount) {\n  const modelInfo = modelDb[model];\n  if (!modelInfo || modelInfo.type !== 'cloud') {\n    throw new Error(`Ungültiges Cloud-Modell: ${model}`);\n  }\n  \n  const inputCost = (inputTokenCount / 1000000) * modelInfo.inputCost;\n  const outputCost = (outputTokenCount / 1000000) * modelInfo.outputCost;\n  \n  // Abgelehnte Anfragen: Wenn der Kontextgröße > maxContext oder erforderliche Qualität > Modellqualität\n  const isRejected = (context_length && context_length > modelInfo.maxContext) || \n                     (quality_threshold && quality_threshold > modelInfo.qualityScore) ||\n                     (require_multimodal && !modelInfo.multimodalCapable);\n  \n  // Verarbeitungszeit in Sekunden\n  const processingTime = isRejected ? 0 : (inputTokenCount + outputTokenCount) / modelInfo.tokenProcessingSpeed;\n  \n  // Antwortlatenz (vereinfacht)\n  const latency = isRejected ? 0 : (processingTime + 1.5); // +1.5s für Netzwerklatenz\n\n  return {\n    inputCost,\n    outputCost,\n    totalCost: inputCost + outputCost,\n    processingTime,\n    latency,\n    isRejected,\n    rejectionReason: isRejected ? getCloudRejectionReason(modelInfo) : null\n  };\n}\n\n// Hilfsfunktion zur Bestimmung des Ablehnungsgrundes\nfunction getCloudRejectionReason(modelInfo) {\n  if (context_length && context_length > modelInfo.maxContext) {\n    return `Kontextgröße (${context_length}) überschreitet maximale Kontextgröße des Modells (${modelInfo.maxContext})`;\n  }\n  if (quality_threshold && quality_threshold > modelInfo.qualityScore) {\n    return `Erforderliche Qualität (${quality_threshold}) überschreitet Modellqualität (${modelInfo.qualityScore})`;\n  }\n  if (require_multimodal && !modelInfo.multimodalCapable) {\n    return \"Modell unterstützt keine multimodalen Aufgaben\";\n  }\n  return \"Unbekannter Grund\";\n}\n\n// Funktion zur Berechnung der Kosten für lokale Modelle\nfunction calculateLocalModelCost(model, inputTokenCount, outputTokenCount) {\n  const modelInfo = modelDb[model];\n  if (!modelInfo || modelInfo.type !== 'local') {\n    throw new Error(`Ungültiges lokales Modell: ${model}`);\n  }\n  \n  // Prüfen, ob das Modell die Anforderungen erfüllt\n  const isRejected = (context_length && context_length > modelInfo.maxContext) || \n                     (quality_threshold && quality_threshold > modelInfo.qualityScore) ||\n                     (require_multimodal && !modelInfo.multimodalCapable);\n  \n  if (isRejected) {\n    return {\n      energyCost: 0,\n      hardwareCost: 0,\n      maintenanceCost: 0,\n      totalCost: 0,\n      processingTime: 0,\n      latency: 0,\n      isRejected: true,\n      rejectionReason: getLocalRejectionReason(modelInfo)\n    };\n  }\n  \n  // Gesamte Tokenanzahl\n  const totalTokens = inputTokenCount + outputTokenCount;\n  \n  // Verarbeitungszeit unter Berücksichtigung der Aufgabenkomplexität\n  const complexityInfo = complexityCategories[task_complexity];\n  const adjustedProcessingTime = totalTokens / modelInfo.tokenProcessingSpeed * \n                                 complexityInfo.processingTimeMultiplier;\n  \n  // Energie- und Hardwarekosten\n  // Energieverbrauch in kWh\n  const energyConsumption = (modelInfo.powerConsumptionW / 1000) * (adjustedProcessingTime / 3600);\n  const energyCost = energyConsumption * energy_cost_per_kwh;\n  \n  // Hardware-Abschreibungskosten\n  let hardwareCost = 0;\n  if (include_hardware_costs) {\n    // Stündliche Hardware-Kosten basierend auf Abschreibungszeitraum\n    const hourlyHardwareCost = modelInfo.hardwareCost / (hardware_amortization_months * 30 * 24);\n    hardwareCost = hourlyHardwareCost * (adjustedProcessingTime / 3600);\n  }\n  \n  // Wartungskosten\n  const hourlyMaintenanceCost = modelInfo.maintenanceCostPerMonth / (30 * 24);\n  const maintenanceCost = hourlyMaintenanceCost * (adjustedProcessingTime / 3600);\n  \n  // Gesamtkosten\n  const totalCost = energyCost + hardwareCost + maintenanceCost;\n  \n  // Latenz ist bei lokalen Modellen gleich der Verarbeitungszeit\n  const latency = adjustedProcessingTime;\n  \n  return {\n    energyCost,\n    hardwareCost,\n    maintenanceCost,\n    totalCost,\n    energyConsumption,\n    processingTime: adjustedProcessingTime,\n    latency,\n    isRejected: false\n  };\n}\n\n// Hilfsfunktion zur Bestimmung des Ablehnungsgrundes für lokale Modelle\nfunction getLocalRejectionReason(modelInfo) {\n  if (context_length && context_length > modelInfo.maxContext) {\n    return `Kontextgröße (${context_length}) überschreitet maximale Kontextgröße des Modells (${modelInfo.maxContext})`;\n  }\n  if (quality_threshold && quality_threshold > modelInfo.qualityScore) {\n    return `Erforderliche Qualität (${quality_threshold}) überschreitet Modellqualität (${modelInfo.qualityScore})`;\n  }\n  if (require_multimodal && !modelInfo.multimodalCapable) {\n    return \"Modell unterstützt keine multimodalen Aufgaben\";\n  }\n  return \"Unbekannter Grund\";\n}\n\n// Hauptfunktion zur Berechnung der Kosten für verschiedene Modelle\nfunction estimateTaskCosts() {\n  // Bestimme die Tokens basierend auf Komplexität oder expliziten Angaben\n  let inputTokenCount, outputTokenCount, requiredContext;\n  \n  if (input_tokens && output_tokens) {\n    // Verwende explizit angegebene Token-Zahlen\n    inputTokenCount = input_tokens;\n    outputTokenCount = output_tokens;\n  } else {\n    // Verwende die durchschnittlichen Token-Zahlen basierend auf der Komplexitätskategorie\n    const complexityInfo = complexityCategories[task_complexity];\n    if (!complexityInfo) {\n      throw new Error(`Ungültige Komplexitätskategorie: ${task_complexity}`);\n    }\n    \n    inputTokenCount = complexityInfo.avgInputTokens;\n    outputTokenCount = complexityInfo.avgOutputTokens;\n    requiredContext = complexityInfo.requiredContextSize;\n  }\n  \n  // Verwende explizite Kontextlänge, falls angegeben, sonst die aus der Komplexitätskategorie\n  const effectiveContextLength = context_length || requiredContext;\n  \n  // Ergebnisse für jedes Modell berechnen\n  const results = {};\n  for (const model of models_to_evaluate) {\n    try {\n      const modelInfo = modelDb[model];\n      if (!modelInfo) {\n        results[model] = { error: `Unbekanntes Modell: ${model}` };\n        continue;\n      }\n      \n      // Prüfe, ob das Modell die grundlegenden Anforderungen erfüllt\n      const complexityInfo = complexityCategories[task_complexity];\n      if (modelInfo.complexityHandling < complexityInfo.minComplexityHandling) {\n        results[model] = { \n          isRejected: true, \n          rejectionReason: `Modell kann die erforderliche Komplexität nicht bewältigen (${task_complexity})`\n        };\n        continue;\n      }\n      \n      // Berechne die spezifischen Kosten je nach Modelltyp\n      if (modelInfo.type === 'cloud') {\n        results[model] = calculateCloudModelCost(model, inputTokenCount, outputTokenCount);\n      } else {\n        results[model] = calculateLocalModelCost(model, inputTokenCount, outputTokenCount);\n      }\n      \n      // Füge weitere Modellinfos hinzu\n      results[model].modelType = modelInfo.type;\n      results[model].provider = modelInfo.provider || 'local';\n      results[model].qualityScore = modelInfo.qualityScore;\n      results[model].maxContext = modelInfo.maxContext;\n      results[model].multimodalCapable = modelInfo.multimodalCapable;\n    } catch (error) {\n      results[model] = { error: error.message };\n    }\n  }\n  \n  // Finde das kostengünstigste geeignete Modell\n  let cheapestModel = null;\n  let lowestCost = Infinity;\n  \n  for (const model in results) {\n    if (!results[model].isRejected && !results[model].error && results[model].totalCost < lowestCost) {\n      cheapestModel = model;\n      lowestCost = results[model].totalCost;\n    }\n  }\n  \n  // Finde das schnellste geeignete Modell\n  let fastestModel = null;\n  let lowestLatency = Infinity;\n  \n  for (const model in results) {\n    if (!results[model].isRejected && !results[model].error && results[model].latency < lowestLatency) {\n      fastestModel = model;\n      lowestLatency = results[model].latency;\n    }\n  }\n  \n  // Finde das qualitativ beste Modell\n  let bestQualityModel = null;\n  let highestQuality = -Infinity;\n  \n  for (const model in results) {\n    const quality = results[model].qualityScore;\n    if (!results[model].isRejected && !results[model].error && quality > highestQuality) {\n      bestQualityModel = model;\n      highestQuality = quality;\n    }\n  }\n  \n  // Berechne die Gesamtkosten bei Verwendung des Cloud-Modells als Referenz\n  let cloudReferenceModel = \"claude-3-5-sonnet\"; // Standardreferenz\n  const cloudCost = results[cloudReferenceModel] && !results[cloudReferenceModel].isRejected ? \n                   results[cloudReferenceModel].totalCost : \n                   null;\n  \n  // Rückgabe der Ergebnisse\n  return {\n    task: {\n      complexity: task_complexity,\n      complexity_description: complexityCategories[task_complexity].description,\n      input_tokens: inputTokenCount,\n      output_tokens: outputTokenCount,\n      total_tokens: inputTokenCount + outputTokenCount,\n      context_length: effectiveContextLength,\n      multimodal_required: require_multimodal,\n      quality_threshold: quality_threshold\n    },\n    model_results: results,\n    recommendations: {\n      most_cost_effective: cheapestModel ? {\n        model: cheapestModel,\n        cost: results[cheapestModel].totalCost,\n        savings_vs_cloud: cloudCost ? (cloudCost - results[cheapestModel].totalCost) : null,\n        savings_percentage: cloudCost ? ((cloudCost - results[cheapestModel].totalCost) / cloudCost * 100) : null\n      } : null,\n      fastest_response: fastestModel ? {\n        model: fastestModel,\n        latency: results[fastestModel].latency\n      } : null,\n      highest_quality: bestQualityModel ? {\n        model: bestQualityModel,\n        quality_score: results[bestQualityModel].qualityScore\n      } : null\n    },\n    meta: {\n      timestamp: new Date().toISOString(),\n      energy_cost_per_kwh: energy_cost_per_kwh,\n      hardware_amortization_months: hardware_amortization_months,\n      include_hardware_costs: include_hardware_costs\n    }\n  };\n}\n\n// Führe die Kostenschätzung aus\ntry {\n  const estimate = estimateTaskCosts();\n  return estimate;\n} catch (error) {\n  return {\n    error: error.message,\n    timestamp: new Date().toISOString()\n  };\n}"
      },
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [440, 300],
      "id": "calculate-task-costs"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "batch-estimate",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 500],
      "id": "batch-estimate-webhook"
    },
    {
      "parameters": {
        "functionCode": "// Batch-Verarbeitung für mehrere Aufgaben\nconst batchRequest = $input.item.json;\nconst { tasks = [], common_parameters = {} } = batchRequest;\n\n// Importiere die Hauptberechnungsfunktion (als Referenz - in n8n müsste dieser Code dupliziert werden)
const calculateTaskCosts = $node[\"calculate-task-costs\"].function;\n\n// Analysiere den Workflow und berechne die Kosten für jeden Schritt\nfunction estimateWorkflowCosts() {\n  // Validiere die Workflow-Struktur\n  if (!workflow_steps || !Array.isArray(workflow_steps) || workflow_steps.length === 0) {\n    throw new Error(\"Workflow-Struktur ist ungültig oder leer\");\n  }\n  \n  // Topologische Sortierung, um die Workflow-Schritte in Ausführungsreihenfolge zu bringen\n  const sortedSteps = topologicalSort(workflow_steps);\n  \n  // Verarbeite jeden Schritt und berechne die Kosten\n  const stepResults = [];\n  const modelUsageCounts = {};\n  \n  for (const step of sortedSteps) {\n    // Kombiniere step-spezifische Parameter mit gemeinsamen Parametern\n    const stepParameters = { ...common_parameters, ...step.parameters };\n    \n    try {\n      // Führe die Kostenschätzung für diesen Schritt aus\n      const result = calculateTaskCosts(stepParameters);\n      \n      // Wähle das beste Modell basierend auf dem Optimierungsziel\n      let selectedModel, selectedCost, selectedLatency, selectedQuality;\n      \n      if (cost_optimization && result.recommendations.most_cost_effective) {\n        // Kostenoptimierung: Wähle das kostengünstigste Modell\n        selectedModel = result.recommendations.most_cost_effective.model;\n        selectedCost = result.recommendations.most_cost_effective.cost;\n        \n        // Extrahiere Latenz und Qualität des gewählten Modells\n        selectedLatency = result.model_results[selectedModel].latency;\n        selectedQuality = result.model_results[selectedModel].qualityScore;\n      } else if (result.recommendations.fastest_response) {\n        // Geschwindigkeitsoptimierung: Wähle das schnellste Modell\n        selectedModel = result.recommendations.fastest_response.model;\n        selectedLatency = result.model_results[selectedModel].latency;\n        \n        // Extrahiere Kosten und Qualität des gewählten Modells\n        selectedCost = result.model_results[selectedModel].totalCost;\n        selectedQuality = result.model_results[selectedModel].qualityScore;\n      } else if (result.recommendations.highest_quality) {\n        // Qualitätsoptimierung: Wähle das qualitativ beste Modell\n        selectedModel = result.recommendations.highest_quality.model;\n        selectedQuality = result.recommendations.highest_quality.quality_score;\n        \n        // Extrahiere Kosten und Latenz des gewählten Modells\n        selectedCost = result.model_results[selectedModel].totalCost;\n        selectedLatency = result.model_results[selectedModel].latency;\n      } else {\n        throw new Error(\"Keine geeigneten Modelle für diesen Workflow-Schritt gefunden\");\n      }\n      \n      // Zähle die Modellnutzung\n      modelUsageCounts[selectedModel] = (modelUsageCounts[selectedModel] || 0) + 1;\n      \n      // Speichere das Ergebnis für diesen Schritt\n      stepResults.push({\n        step_id: step.id,\n        step_name: step.name || `Schritt ${stepResults.length + 1}`,\n        description: step.description || \"\",\n        complexity: step.parameters?.task_complexity || common_parameters.task_complexity || \"medium\",\n        selected_model: selectedModel,\n        cost: selectedCost,\n        latency: selectedLatency,\n        quality: selectedQuality,\n        token_counts: {\n          input: result.task.input_tokens,\n          output: result.task.output_tokens,\n          total: result.task.total_tokens\n        },\n        full_result: result\n      });\n    } catch (error) {\n      stepResults.push({\n        step_id: step.id,\n        step_name: step.name || `Schritt ${stepResults.length + 1}`,\n        description: step.description || \"\",\n        complexity: step.parameters?.task_complexity || common_parameters.task_complexity || \"medium\",\n        error: error.message\n      });\n    }\n  }\n  \n  // Berechne die kritischen Pfade und die Gesamtkosten\n  const criticalPath = calculateCriticalPath(workflow_steps, stepResults);\n  const totalWorkflowCost = stepResults.reduce((sum, step) => sum + (step.cost || 0), 0);\n  const totalWorkflowTime = criticalPath.totalTime;\n  \n  // Berechne die Kosten für verschiedene Zeiträume\n  const projectedCosts = projectCostsOverTime(\n    totalWorkflowCost, \n    daily_executions, \n    monthly_growth_rate, \n    projection_months\n  );\n  \n  // Rückgabe der Workflow-Ergebnisse mit Zusammenfassung\n  return {\n    workflow_results: {\n      steps: stepResults,\n      critical_path: criticalPath.path,\n      execution_time: totalWorkflowTime,\n      cost_per_execution: totalWorkflowCost\n    },\n    model_usage: Object.entries(modelUsageCounts).map(([model, count]) => ({\n      model,\n      step_count: count,\n      percentage: (count / stepResults.length) * 100\n    })),\n    cost_projections: projectedCosts,\n    summary: {\n      total_steps: stepResults.length,\n      successful_estimates: stepResults.filter(r => !r.error).length,\n      failed_estimates: stepResults.filter(r => r.error).length,\n      cost_per_execution: totalWorkflowCost,\n      daily_cost: totalWorkflowCost * daily_executions,\n      monthly_cost: totalWorkflowCost * daily_executions * 30,\n      annual_cost: totalWorkflowCost * daily_executions * 365,\n      projected_annual_cost_with_growth: projectedCosts.annual,\n      execution_time_seconds: totalWorkflowTime\n    },\n    optimization_strategy: cost_optimization ? \"cost\" : \"performance\",\n    timestamp: new Date().toISOString()\n  };\n}\n\n// Topologische Sortierung der Workflow-Schritte\nfunction topologicalSort(steps) {\n  // Erstelle eine Kopie der Schritte, um die Originaldaten nicht zu verändern\n  const nodesCopy = JSON.parse(JSON.stringify(steps));\n  \n  // Erstelle die Abhängigkeitsgraphen\n  const graph = {};\n  const inDegree = {};\n  \n  // Initialisiere Graphen\n  for (const node of nodesCopy) {\n    graph[node.id] = [];\n    inDegree[node.id] = 0;\n  }\n  \n  // Fülle die Graphen mit Abhängigkeiten\n  for (const node of nodesCopy) {\n    if (node.dependencies && Array.isArray(node.dependencies)) {\n      for (const depId of node.dependencies) {\n        if (graph[depId]) {\n          graph[depId].push(node.id);\n          inDegree[node.id] = (inDegree[node.id] || 0) + 1;\n        }\n      }\n    }\n  }\n  \n  // Kahn's Algorithmus für topologische Sortierung\n  const queue = [];\n  for (const nodeId in inDegree) {\n    if (inDegree[nodeId] === 0) {\n      queue.push(nodeId);\n    }\n  }\n  \n  const result = [];\n  while (queue.length > 0) {\n    const nodeId = queue.shift();\n    const node = nodesCopy.find(n => n.id === nodeId);\n    if (node) {\n      result.push(node);\n    }\n    \n    for (const neighbor of graph[nodeId]) {\n      inDegree[neighbor]--;\n      if (inDegree[neighbor] === 0) {\n        queue.push(neighbor);\n      }\n    }\n  }\n  \n  // Prüfe auf Zyklen im Graphen\n  if (result.length !== nodesCopy.length) {\n    throw new Error(\"Der Workflow enthält Zyklen und kann nicht sortiert werden\");\n  }\n  \n  return result;\n}\n\n// Berechnung des kritischen Pfades im Workflow\nfunction calculateCriticalPath(steps, results) {\n  // Erstelle eine Map der Schrittergebnisse nach ID\n  const resultMap = {};\n  for (const result of results) {\n    if (!result.error) {\n      resultMap[result.step_id] = result;\n    }\n  }\n  \n  // Erstelle den Abhängigkeitsgraphen\n  const graph = {};\n  for (const step of steps) {\n    graph[step.id] = step.dependencies || [];\n  }\n  \n  // Berechne den frühesten Start- und Endzeitpunkt für jeden Schritt\n  const earliestStart = {};\n  const earliestFinish = {};\n  \n  // Initialisiere alle Schritte mit einem frühesten Start von 0\n  for (const step of steps) {\n    earliestStart[step.id] = 0;\n    earliestFinish[step.id] = 0;\n  }\n  \n  // Topologisch sortierte Schritte verwenden, um Vorwärtsdurchlauf zu machen\n  const sortedSteps = topologicalSort(steps);\n  \n  for (const step of sortedSteps) {\n    if (step.dependencies && step.dependencies.length > 0) {\n      // Finde den spätesten Endzeitpunkt aller Vorgänger\n      let maxPredecessorFinish = 0;\n      for (const predId of step.dependencies) {\n        if (earliestFinish[predId] > maxPredecessorFinish) {\n          maxPredecessorFinish = earliestFinish[predId];\n        }\n      }\n      earliestStart[step.id] = maxPredecessorFinish;\n    }\n    \n    // Berechne den frühesten Endzeitpunkt basierend auf der Verarbeitungszeit\n    if (resultMap[step.id]) {\n      earliestFinish[step.id] = earliestStart[step.id] + (resultMap[step.id].latency || 0);\n    } else {\n      // Fallback für Schritte ohne Ergebnis\n      earliestFinish[step.id] = earliestStart[step.id];\n    }\n  }\n  \n  // Finde den spätesten Endzeitpunkt (Projektende)\n  let projectEnd = 0;\n  for (const stepId in earliestFinish) {\n    if (earliestFinish[stepId] > projectEnd) {\n      projectEnd = earliestFinish[stepId];\n    }\n  }\n  \n  // Berechne den spätesten Start- und Endzeitpunkt für jeden Schritt\n  const latestStart = {};\n  const latestFinish = {};\n  \n  // Initialisiere alle Schritte mit einem spätesten Ende von Projektende\n  for (const step of steps) {\n    latestFinish[step.id] = projectEnd;\n    latestStart[step.id] = projectEnd;\n  }\n  \n  // Rückwärtsdurchlauf durch den Graphen\n  for (const step of sortedSteps.slice().reverse()) {\n    if (graph[step.id].length > 0) {\n      // Finde den frühesten Startzeitpunkt aller Nachfolger\n      let minSuccessorStart = projectEnd;\n      for (const succId of graph[step.id]) {\n        if (latestStart[succId] < minSuccessorStart) {\n          minSuccessorStart = latestStart[succId];\n        }\n      }\n      latestFinish[step.id] = minSuccessorStart;\n    } else {\n      // Für Schritte ohne Nachfolger ist der späteste Endzeitpunkt gleich dem Projektende\n      latestFinish[step.id] = projectEnd;\n    }\n    \n    // Berechne den spätesten Startzeitpunkt basierend auf der Verarbeitungszeit\n    if (resultMap[step.id]) {\n      latestStart[step.id] = latestFinish[step.id] - (resultMap[step.id].latency || 0);\n    } else {\n      // Fallback für Schritte ohne Ergebnis\n      latestStart[step.id] = latestFinish[step.id];\n    }\n  }\n  \n  // Berechne den Puffer für jeden Schritt und identifiziere kritische Schritte\n  const slack = {};\n  const criticalSteps = [];\n  \n  for (const step of steps) {\n    slack[step.id] = latestStart[step.id] - earliestStart[step.id];\n    if (slack[step.id] === 0) {\n      criticalSteps.push(step.id);\n    }\n  }\n  \n  // Erstelle den kritischen Pfad\n  const criticalPath = [];\n  for (const stepId of criticalSteps) {\n    const step = steps.find(s => s.id === stepId);\n    if (step && resultMap[stepId]) {\n      criticalPath.push({\n        step_id: stepId,\n        step_name: step.name || stepId,\n        start_time: earliestStart[stepId],\n        end_time: earliestFinish[stepId],\n        duration: resultMap[stepId].latency || 0\n      });\n    }\n  }\n  \n  // Sortiere den kritischen Pfad nach Startzeit\n  criticalPath.sort((a, b) => a.start_time - b.start_time);\n  \n  return {\n    path: criticalPath,\n    totalTime: projectEnd\n  };\n}\n\n// Projektion der Kosten über die Zeit\nfunction projectCostsOverTime(baseCost, dailyExecutions, monthlyGrowthRate, months) {\n  const projections = {\n    monthly: [],\n    quarterly: [],\n    annual: 0\n  };\n  \n  let currentDailyExecutions = dailyExecutions;\n  let totalAnnualCost = 0;\n  \n  for (let month = 1; month <= months; month++) {\n    // Berechne die monatlichen Kosten\n    const monthlyCost = baseCost * currentDailyExecutions * 30;\n    \n    // Füge zur monatlichen Projektion hinzu\n    projections.monthly.push({\n      month,\n      executions_per_day: currentDailyExecutions,\n      cost: monthlyCost\n    });\n    \n    // Füge zur vierteljährlichen Projektion hinzu, falls ein Quartal abgeschlossen ist\n    if (month % 3 === 0) {\n      const quarterlyData = {\n        quarter: Math.floor(month / 3),\n        months: [(month - 2), (month - 1), month],\n        cost: projections.monthly.slice(-3).reduce((sum, m) => sum + m.cost, 0)\n      };\n      projections.quarterly.push(quarterlyData);\n    }\n    \n    // Summiere die jährlichen Kosten\n    totalAnnualCost += monthlyCost;\n    \n    // Aktualisiere die täglichen Ausführungen basierend auf der Wachstumsrate\n    currentDailyExecutions *= (1 + (monthlyGrowthRate / 100));\n  }\n  \n  // Speichere die Gesamtjahreskosten\n  projections.annual = totalAnnualCost;\n  \n  return projections;\n}\n\n// Führe die Workflow-Kostenschätzung aus\ntry {\n  const workflowEstimate = estimateWorkflowCosts();\n  return workflowEstimate;\n} catch (error) {\n  return {\n    error: error.message,\n    timestamp: new Date().toISOString()\n  };\n}"
      },
echnungsfunktion (als Referenz - in n8n müsste dieser Code dupliziert werden)\nconst calculateTaskCosts = $node[\"calculate-task-costs\"].function;\n\n// Verarbeite jede Aufgabe in der Gruppe\nconst batchResults = [];\n\nfor (const task of tasks) {\n  // Kombiniere aufgabenspezifische Parameter mit gemeinsamen Parametern\n  const combinedParameters = { ...common_parameters, ...task };\n  \n  try {\n    // Führe die Kostenschätzung für diese Aufgabe aus\n    const result = calculateTaskCosts(combinedParameters);\n    batchResults.push({\n      task_id: task.task_id || `Task-${batchResults.length + 1}`,\n      task_description: task.description || `Aufgabe ${batchResults.length + 1}`,\n      complexity: task.task_complexity || common_parameters.task_complexity || \"medium\",\n      result: result\n    });\n  } catch (error) {\n    batchResults.push({\n      task_id: task.task_id || `Task-${batchResults.length + 1}`,\n      task_description: task.description || `Aufgabe ${batchResults.length + 1}`,\n      complexity: task.task_complexity || common_parameters.task_complexity || \"medium\",\n      error: error.message\n    });\n  }\n}\n\n// Berechne die Gesamtkosten\nlet totalCloudCost = 0;\nlet totalLocalCost = 0;\nlet totalSavings = 0;\n\nfor (const result of batchResults) {\n  if (result.result && result.result.recommendations && result.result.recommendations.most_cost_effective) {\n    const recommendation = result.result.recommendations.most_cost_effective;\n    \n    // Kostengünstigstes Modell\n    const bestModelCost = recommendation.cost || 0;\n    \n    // Cloud-Referenzkosten\n    const cloudCost = recommendation.savings_vs_cloud !== null ? \n                      bestModelCost + recommendation.savings_vs_cloud : \n                      bestModelCost; // Fallback, falls keine Ersparnisse berechnet wurden\n    \n    // Summieren\n    if (result.result.model_results[recommendation.model].modelType === 'cloud') {\n      totalCloudCost += bestModelCost;\n    } else {\n      totalLocalCost += bestModelCost;\n    }\n    \n    // Ersparnisse\n    totalSavings += (recommendation.savings_vs_cloud || 0);\n  }\n}\n\n// Rückgabe der Batch-Ergebnisse mit Zusammenfassung\nreturn {\n  batch_results: batchResults,\n  summary: {\n    total_tasks: batchResults.length,\n    successful_estimates: batchResults.filter(r => !r.error).length,\n    failed_estimates: batchResults.filter(r => r.error).length,\n    total_cloud_cost: totalCloudCost,\n    total_local_cost: totalLocalCost,\n    total_cost: totalCloudCost + totalLocalCost,\n    total_savings_vs_all_cloud: totalSavings,\n    savings_percentage: totalSavings > 0 ? (totalSavings / (totalCloudCost + totalLocalCost + totalSavings) * 100) : 0\n  },\n  timestamp: new Date().toISOString()\n};"
      },
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [440, 500],
      "id": "process-batch-estimates"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "workflow-cost-estimate",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 700],
      "id": "workflow-cost-webhook"
    },
    {
      "parameters": {
        "functionCode": "// Workflow-Kosten-Schätzung für komplette Prozess-Workflows\nconst workflowRequest = $input.item.json;\n\n// Extrahiere Parameter mit Defaults\nconst {\n  workflow_steps = [],           // Array von Workflow-Schritten mit Abhängigkeiten\n  common_parameters = {},       // Gemeinsame Parameter für alle Schritte\n  daily_executions = 1,         // Tägliche Ausführungen\n  monthly_growth_rate = 0,      // Monatliche Wachstumsrate in Prozent\n  projection_months = 12,       // Anzahl der Monate für die Projektion\n  cost_optimization = true      // Ob Kosten optimiert werden sollen\n} = workflowRequest;\n\n// Importiere die Hauptber
    const stepId in earliestFinish) {\n    if (earliestFinish[stepId] > projectEnd) {\n      projectEnd = earliestFinish[stepId];\n    }\n  }\n  \n  // Berechne den spätesten Start- und Endzeitpunkt für jeden Schritt\n  const latestStart = {};\n  const latestFinish = {};\n  \n  // Initialisiere alle Schritte mit einem spätesten Ende von Projektende\n  for (const step of steps) {\n    latestFinish[step.id] = projectEnd;\n    latestStart[step.id] = projectEnd;\n  }\n  \n  // Rückwärtsdurchlauf durch den Graphen\n  for (const step of sortedSteps.slice().reverse()) {\n    if (graph[step.id].length > 0) {\n      // Finde den frühesten Startzeitpunkt aller Nachfolger\n      let minSuccessorStart = projectEnd;\n      for (const succId of graph[step.id]) {\n        if (latestStart[succId] < minSuccessorStart) {\n          minSuccessorStart = latestStart[succId];\n        }\n      }\n      latestFinish[step.id] = minSuccessorStart;\n    } else {\n      // Für Schritte ohne Nachfolger ist der späteste Endzeitpunkt gleich dem Projektende\n      latestFinish[step.id] = projectEnd;\n    }\n    \n    // Berechne den spätesten Startzeitpunkt basierend auf der Verarbeitungszeit\n    if (resultMap[step.id]) {\n      latestStart[step.id] = latestFinish[step.id] - (resultMap[step.id].latency || 0);\n    } else {\n      // Fallback für Schritte ohne Ergebnis\n      latestStart[step.id] = latestFinish[step.id];\n    }\n  }\n  \n  // Berechne den Puffer für jeden Schritt und identifiziere kritische Schritte\n  const slack = {};\n  const criticalSteps = [];\n  \n  for (const step of steps) {\n    slack[step.id] = latestStart[step.id] - earliestStart[step.id];\n    if (slack[step.id] === 0) {\n      criticalSteps.push(step.id);\n    }\n  }\n  \n  // Erstelle den kritischen Pfad\n  const criticalPath = [];\n  for (const stepId of criticalSteps) {\n    const step = steps.find(s => s.id === stepId);\n    if (step && resultMap[stepId]) {\n      criticalPath.push({\n        step_id: stepId,\n        step_name: step.name || stepId,\n        start_time: earliestStart[stepId],\n        end_time: earliestFinish[stepId],\n        duration: resultMap[stepId].latency || 0\n      });\n    }\n  }\n  \n  // Sortiere den kritischen Pfad nach Startzeit\n  criticalPath.sort((a, b) => a.start_time - b.start_time);\n  \n  return {\n    path: criticalPath,\n    totalTime: projectEnd\n  };\n}\n\n// Projektion der Kosten über die Zeit\nfunction projectCostsOverTime(baseCost, dailyExecutions, monthlyGrowthRate, months) {\n  const projections = {\n    monthly: [],\n    quarterly: [],\n    annual: 0\n  };\n  \n  let currentDailyExecutions = dailyExecutions;\n  let totalAnnualCost = 0;\n  \n  for (let month = 1; month <= months; month++) {\n    // Berechne die monatlichen Kosten\n    const monthlyCost = baseCost * currentDailyExecutions * 30;\n    \n    // Füge zur monatlichen Projektion hinzu\n    projections.monthly.push({\n      month,\n      executions_per_day: currentDailyExecutions,\n      cost: monthlyCost\n    });\n    \n    // Füge zur vierteljährlichen Projektion hinzu, falls ein Quartal abgeschlossen ist\n    if (month % 3 === 0) {\n      const quarterlyData = {\n        quarter: Math.floor(month / 3),\n        months: [(month - 2), (month - 1), month],\n        cost: projections.monthly.slice(-3).reduce((sum, m) => sum + m.cost, 0)\n      };\n      projections.quarterly.push(quarterlyData);\n    }\n    \n    // Summiere die jährlichen Kosten\n    totalAnnualCost += monthlyCost;\n    \n    // Aktualisiere die täglichen Ausführungen basierend auf der Wachstumsrate\n    currentDailyExecutions *= (1 + (monthlyGrowthRate / 100));\n  }\n  \n  // Speichere die Gesamtjahreskosten\n  projections.annual = totalAnnualCost;\n  \n  return projections;\n}\n\n// Führe die Workflow-Kostenschätzung aus\ntry {\n  const workflowEstimate = estimateWorkflowCosts();\n  return workflowEstimate;\n} catch (error) {\n  return {\n    error: error.message,\n    timestamp: new Date().toISOString()\n  };\n}"
      },
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [440, 700],
      "id": "calculate-workflow-costs"
    },
    {
      "parameters": {
        "httpMethod": "GET",
        "path": "complexity-categories",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 900],
      "id": "complexity-categories-webhook"
    },
    {
      "parameters": {
        "functionCode": "// Gibt die verfügbaren Komplexitätskategorien mit ihren Beschreibungen zurück\n\n// Definition der Komplexitätskategorien\nconst complexityCategories = {\n  \"very_simple\": {\n    description: \"Sehr einfache Aufgaben: Klassifikation, kurze Antworten, einfache Fragen\",\n    avgInputTokens: 200,\n    avgOutputTokens: 100,\n    minComplexityHandling: 4.0,\n    requiredContextSize: 1024,\n    processingTimeMultiplier: 1.0,\n    examples: [\n      \"Ist dieser Text positiv oder negativ?\",\n      \"Was ist die Hauptstadt von Frankreich?\",\n      \"Konvertiere 10 USD in EUR\"\n    ]\n  },\n  \"simple\": {\n    description: \"Einfache Aufgaben: Zusammenfassungen, kurze Texte, einfache Faktenrecherche\",\n    avgInputTokens: 1000,\n    avgOutputTokens: 300,\n    minComplexityHandling: 5.0,\n    requiredContextSize: 2048,\n    processingTimeMultiplier: 1.2,\n    examples: [\n      \"Fasse diesen Artikel in drei Sätzen zusammen\",\n      \"Erkläre das Konzept der Photosynthese\",\n      \"Wie funktioniert ein Elektromotor?\"\n    ]\n  },\n  \"medium\": {\n    description: \"Mittlere Komplexität: Standard-Codegeneration, detaillierte Antworten, Analysen\",\n    avgInputTokens: 2000,\n    avgOutputTokens: 800,\n    minComplexityHandling: 6.5,\n    requiredContextSize: 4096,\n    processingTimeMultiplier: 1.5,\n    examples: [\n      \"Schreibe eine Python-Funktion zur Berechnung der Fibonacci-Folge\",\n      \"Analysiere die wichtigsten Faktoren des Klimawandels\",\n      \"Vergleiche die Vor- und Nachteile von REST und GraphQL\"\n    ]\n  },\n  \"complex\": {\n    description: \"Komplexe Aufgaben: Tiefe Textanalysen, fortgeschrittene Codegeneration, logisches Reasoning\",\n    avgInputTokens: 4000,\n    avgOutputTokens: 1500,\n    minComplexityHandling: 7.5,\n    requiredContextSize: 8192,\n    processingTimeMultiplier: 2.0,\n    examples: [\n      \"Implementiere einen effizienten Algorithmus zur Pfadfindung in einem Graphen\",\n      \"Analysiere die Marktchancen für ein neues Produkt in der Biotechnologie\",\n      \"Entwickle einen modularen Workflow für die Integration von mehreren APIs\"\n    ]\n  },\n  \"very_complex\": {\n    description: \"Sehr komplexe Aufgaben: Multi-step Reasoning, detaillierte Berichte, komplexe Problemlösung\",\n    avgInputTokens: 8000,\n    avgOutputTokens: 3000,\n    minComplexityHandling: 8.5,\n    requiredContextSize: 16384,\n    processingTimeMultiplier: 3.0,\n    examples: [\n      \"Erstelle eine detaillierte Kostenanalyse für ein Softwareprojekt mit mehreren Komponenten\",\n      \"Entwickle eine vollständige Architektur für ein verteiltes System\",\n      \"Analysiere einen wissenschaftlichen Artikel und finde methodische Schwächen\"\n    ]\n  },\n  \"extremely_complex\": {\n    description: \"Extrem komplexe Aufgaben: Forschungssynthesen, hochkomplexe Logikketten, AI-Agenten-Systeme\",\n    avgInputTokens: 15000,\n    avgOutputTokens: 4000,\n    minComplexityHandling: 9.5,\n    requiredContextSize: 32768,\n    processingTimeMultiplier: 4.0,\n    examples: [\n      \"Entwickle einen vollständigen Forschungsüberblick über den aktuellen Stand der Quantencomputer\",\n      \"Erstelle ein System von kooperierenden AI-Agenten mit unterschiedlichen Spezialisierungen\",\n      \"Implementiere ein komplexes Simulationsmodell für Klimaprognosen\"\n    ]\n  }\n};\n\n// Formatiere die Ausgabe für eine bessere Benutzerfreundlichkeit\nconst formattedCategories = {};\n\nfor (const [category, info] of Object.entries(complexityCategories)) {\n  formattedCategories[category] = {\n    description: info.description,\n    average_tokens: {\n      input: info.avgInputTokens,\n      output: info.avgOutputTokens,\n      total: info.avgInputTokens + info.avgOutputTokens\n    },\n    minimum_requirements: {\n      model_capability: info.minComplexityHandling,\n      context_length: info.requiredContextSize\n    },\n    processing_time_factor: info.processingTimeMultiplier,\n    examples: info.examples\n  };\n}\n\nreturn {\n  complexity_categories: formattedCategories,\n  usage_tips: {\n    selecting_complexity: \"Wählen Sie die Komplexitätskategorie basierend auf der Art der Aufgabe und der erwarteten Tokenanzahl.\",\n    custom_tokens: \"Wenn Sie die genaue Token-Anzahl kennen, können Sie diese direkt angeben, anstatt eine Komplexitätskategorie zu verwenden.\",\n    context_length: \"Beachten Sie, dass komplexere Aufgaben in der Regel längere Kontextfenster benötigen.\"\n  }\n};"
      },
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [440, 900],
      "id": "get-complexity-categories"
    },
    {
      "parameters": {
        "httpMethod": "GET",
        "path": "available-models",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 1100],
      "id": "available-models-webhook"
    },
    {
      "parameters": {
        "functionCode": "// Gibt die verfügbaren LLM-Modelle mit ihren Spezifikationen zurück\n\n// Modell-Datenbank mit Kosten und Funktionen\nconst modelDb = {\n  // Cloud-Modelle\n  \"claude-3-5-sonnet\": {\n    \"type\": \"cloud\",\n    \"provider\": \"anthropic\",\n    \"inputCost\": 3.0,     // € pro 1M Tokens\n    \"outputCost\": 15.0,   // € pro 1M Tokens\n    \"maxContext\": 200000,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 150,  // Tokens pro Sekunde\n    \"complexityHandling\": 9.5,    // 1-10 Skala\n    \"qualityScore\": 9.5,          // 1-10 Skala\n    \"multimodalCapable\": true\n  },\n  \"claude-3-opus\": {\n    \"type\": \"cloud\",\n    \"provider\": \"anthropic\",\n    \"inputCost\": 15.0,\n    \"outputCost\": 75.0,\n    \"maxContext\": 200000,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 100,\n    \"complexityHandling\": 10.0,\n    \"qualityScore\": 10.0,\n    \"multimodalCapable\": true\n  },\n  \"gpt-4o\": {\n    \"type\": \"cloud\",\n    \"provider\": \"openai\",\n    \"inputCost\": 10.0,\n    \"outputCost\": 30.0,\n    \"maxContext\": 128000,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 120,\n    \"complexityHandling\": 9.5,\n    \"qualityScore\": 9.5,\n    \"multimodalCapable\": true\n  },\n  \"gpt-4o-mini\": {\n    \"type\": \"cloud\",\n    \"provider\": \"openai\",\n    \"inputCost\": 5.0,\n    \"outputCost\": 15.0,\n    \"maxContext\": 128000,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 150,\n    \"complexityHandling\": 9.0,\n    \"qualityScore\": 8.8,\n    \"multimodalCapable\": true\n  },\n  \n  // Lokale Modelle\n  \"local-1.5b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 1500,          // Anschaffungskosten in €\n    \"powerConsumptionW\": 150,      // Watt\n    \"maxContext\": 2048,\n    \"maxOutput\": 2048,\n    \"tokenProcessingSpeed\": 100,    // Tokens pro Sekunde\n    \"complexityHandling\": 4.5,      // 1-10 Skala\n    \"qualityScore\": 5.0,            // 1-10 Skala\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 50\n  },\n  \"local-3b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 2000,\n    \"powerConsumptionW\": 200,\n    \"maxContext\": 4096,\n    \"maxOutput\": 2048,\n    \"tokenProcessingSpeed\": 80,\n    \"complexityHandling\": 5.5,\n    \"qualityScore\": 6.0,\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 75\n  },\n  \"local-7b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 2500,\n    \"powerConsumptionW\": 300,\n    \"maxContext\": 8192,\n    \"maxOutput\": 2048,\n    \"tokenProcessingSpeed\": 50,\n    \"complexityHandling\": 7.0,\n    \"qualityScore\": 7.5,\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 100\n  },\n  \"local-13b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 3000,\n    \"powerConsumptionW\": 400,\n    \"maxContext\": 8192,\n    \"maxOutput\": 2048,\n    \"tokenProcessingSpeed\": 30,\n    \"complexityHandling\": 7.5,\n    \"qualityScore\": 8.0,\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 125\n  },\n  \"local-34b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 7500,\n    \"powerConsumptionW\": 800,\n    \"maxContext\": 16384,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 15,\n    \"complexityHandling\": 8.5,\n    \"qualityScore\": 8.8,\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 200\n  },\n  \"local-70b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 15000,\n    \"powerConsumptionW\": 1200,\n    \"maxContext\": 32768,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 8,\n    \"complexityHandling\": 9.0,\n    \"qualityScore\": 9.2,\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 300\n  }\n};\n\n// Gruppiere Modelle nach Typ\nconst cloudModels = [];\nconst localModels = [];\n\nfor (const [modelId, modelInfo] of Object.entries(modelDb)) {\n  const modelData = {\n    id: modelId,\n    ...modelInfo\n  };\n  \n  if (modelInfo.type === 'cloud') {\n    cloudModels.push(modelData);\n  } else {\n    localModels.push(modelData);\n  }\n}\n\n// Sortiere nach Komplexitätshandhabung (aufsteigend)\ncloudModels.sort((a, b) => a.complexityHandling - b.complexityHandling);\nlocalModels.sort((a, b) => a.complexityHandling - b.complexityHandling);\n\n// Rückgabe der formatierten Modellinfos\nreturn {\n  cloud_models: cloudModels,\n  local_models: localModels,\n  model_capabilities: {\n    quality_scale: \"Qualitätswerte liegen auf einer Skala von 1 (niedrig) bis 10 (ausgezeichnet)\",\n    complexity_scale: \"Komplexitätshandhabung liegt auf einer Skala von 1 (einfach) bis 10 (hochkomplex)\",\n    context_length_explanation: \"Die maximale Kontextlänge gibt an, wie viele Tokens das Modell verarbeiten kann\"\n  },\n  pricing_notes: {\n    cloud_models: \"Cloud-Modellkosten werden pro Million Token berechnet, getrennt für Input und Output\",\n    local_models: \"Für lokale Modelle fallen einmalige Hardware-Kosten sowie Strom- und Wartungskosten an\"\n  }\n};"
      },
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [440, 1100],
      "id": "get-available-models"
    },
    {
      "parameters": {
        "functionCode": "// Generiert visuelle Darstellungen der Kostenschätzungen\n\n// Diese Funktion würde in einer realen Implementierung Visualisierungen erstellen\n// Hier ist eine Platzhalterfunktion, die JSON-Daten für ein Chart.js-Diagramm generiert\n\nfunction generateChartConfig(data, type = 'bar') {\n  // Standardkonfiguration für Chart.js\n  const config = {\n    type: type,\n    data: {\n      labels: [],\n      datasets: []\n    },\n    options: {\n      responsive: true,\n      plugins: {\n        title: {\n          display: true,\n          text: ''\n        },\n        tooltip: {\n          callbacks: {}\n        }\n      }\n    }\n  };\n  \n  // Konfiguration je nach Datentyp anpassen\n  if (data.model_results) {\n    // Für einzelne Task-Kosten\n    config.options.plugins.title.text = 'Kostenvergleich nach Modell';\n    \n    const modelNames = Object.keys(data.model_results);\n    const costs = [];\n    const latencies = [];\n    const qualityScores = [];\n    const backgroundColors = [];\n    \n    for (const model of modelNames) {\n      const modelData = data.model_results[model];\n      if (!modelData.isRejected && !modelData.error) {\n        costs.push(modelData.totalCost);\n        latencies.push(modelData.latency);\n        qualityScores.push(modelData.qualityScore * 10); // Skalierung für bessere Sichtbarkeit\n        \n        // Farben nach Modelltyp\n        if (modelData.modelType === 'cloud') {\n          backgroundColors.push('rgba(54, 162, 235, 0.6)');\n        } else {\n          backgroundColors.push('rgba(75, 192, 192, 0.6)');\n        }\n      }\n    }\n    \n    config.data.labels = modelNames.filter((_, i) => costs[i] !== undefined);\n    config.data.datasets = [\n      {\n        label: 'Kosten (€)',\n        data: costs,\n        backgroundColor: backgroundColors,\n        yAxisID: 'y'\n      },\n      {\n        label: 'Latenz (s)',\n        data: latencies,\n        backgroundColor: 'rgba(255, 99, 132, 0.6)',\n        yAxisID: 'y1'\n      },\n      {\n        label: 'Qualität (x10)',\n        data: qualityScores,\n        backgroundColor: 'rgba(255, 206, 86, 0.6)',\n        yAxisID: 'y2'\n      }\n    ];\n    \n    config.options.scales = {\n      y: {\n        type: 'linear',\n        display: true,\n        position: 'left',\n        title: {\n          display: true,\n          text: 'Kosten (€)'\n        }\n      },\n      y1: {\n        type: 'linear',\n        display: true,\n        position: 'right',\n        title: {\n          display: true,\n          text: 'Latenz (s)'\n        },\n        grid: {\n          drawOnChartArea: false\n        }\n      },\n      y2: {\n        type: 'linear',\n        display: true,\n        position: 'right',\n        title: {\n          display: true,\n          text: 'Qualität'\n        },\n        grid: {\n          drawOnChartArea: false\n        }\n      }\n    };\n  } else if (data.cost_projections && data.cost_projections.monthly) {\n    // Für Kostenprognosen\n    config.type = 'line';\n    config.options.plugins.title.text = 'Kostenprognose über Zeit';\n    \n    const months = data.cost_projections.monthly.map(m => `Monat ${m.month}`);\n    const costs = data.cost_projections.monthly.map(m => m.cost);\n    \n    config.data.labels = months;\n    config.data.datasets = [\n      {\n        label: 'Monatliche Kosten (€)',\n        data: costs,\n        borderColor: 'rgba(75, 192, 192, 1)',\n        backgroundColor: 'rgba(75, 192, 192, 0.2)',\n        tension: 0.1,\n        fill: true\n      }\n    ];\n  } else if (data.workflow_results && data.workflow_results.steps) {\n    // Für Workflow-Kosten\n    config.options.plugins.title.text = 'Kostenverteilung im Workflow';\n    \n    const stepNames = data.workflow_results.steps\n      .filter(step => !step.error)\n      .map(step => step.step_name);\n      \n    const stepCosts = data.workflow_results.steps\n      .filter(step => !step.error)\n      .map(step => step.cost);\n      \n    const stepLatencies = data.workflow_results.steps\n      .filter(step => !step.error)\n      .map(step => step.latency);\n    \n    config.data.labels = stepNames;\n    config.data.datasets = [\n      {\n        label: 'Kosten pro Schritt (€)',\n        data: stepCosts,\n        backgroundColor: 'rgba(75, 192, 192, 0.6)'\n      }\n    ];\n    \n    // Zweiter Charttyp für die Ausführungszeit\n    const latencyChartConfig = JSON.parse(JSON.stringify(config));\n    latencyChartConfig.options.plugins.title.text = 'Ausführungszeit im Workflow';\n    latencyChartConfig.data.datasets = [\n      {\n        label: 'Latenz pro Schritt (s)',\n        data: stepLatencies,\n        backgroundColor: 'rgba(255, 99, 132, 0.6)'\n      }\n    ];\n    \n    return [config, latencyChartConfig];\n  }\n  \n  return config;\n}\n\n// Verarbeite die Daten und generiere die entsprechenden Visualisierungen\nfunction generateVisualizations(data) {\n  // Prüfe den Datentyp und generiere entsprechende Visualisierungen\n  if (data.task && data.model_results) {\n    // Einzelne Task-Kostenschätzung\n    return {\n      cost_comparison_chart: generateChartConfig(data, 'bar'),\n      recommendations: {\n        most_cost_effective: data.recommendations.most_cost_effective,\n        fastest_response: data.recommendations.fastest_response,\n        highest_quality: data.recommendations.highest_quality\n      }\n    };\n  } else if (data.batch_results) {\n    // Batch-Verarbeitung mehrerer Aufgaben\n    return {\n      batch_summary_chart: generateChartConfig({\n        cost_projections: {\n          monthly: data.batch_results.map((result, index) => ({\n            month: index + 1,\n            cost: result.result?.recommendations?.most_cost_effective?.cost || 0\n          }))\n        }\n      }, 'line'),\n      task_comparison: {\n        labels: data.batch_results.map(result => result.task_id || result.task_description),\n        costs: data.batch_results.map(result => result.result?.recommendations?.most_cost_effective?.cost || 0)\n      }\n    };\n  } else if (data.workflow_results) {\n    // Workflow-Kostenschätzung\n    const charts = generateChartConfig(data, 'bar');\n    return {\n      workflow_cost_chart: charts[0],\n      workflow_latency_chart: charts[1],\n      critical_path_visualization: {\n        steps: data.workflow_results.critical_path.map(step => ({\n          id: step.step_id,\n          name: step.step_name,\n          start: step.start_time,\n          end: step.end_time,\n          duration: step.duration\n        }))\n      }\n    };\n  }\n  \n  // Fallback für unbekannte Datentypen\n  return {\n    error: \"Keine passende Visualisierung für diesen Datentyp verfügbar\"\n  };\n}\n\n// Beispielaufruf mit Demo-Daten\nconst demoData = {\n  task: {\n    complexity: \"medium\",\n    input_tokens: 2000,\n    output_tokens: 800\n  },\n  model_results: {\n    \"claude-3-5-sonnet\": {\n      totalCost: 0.042,\n      latency: 18.7,\n      qual{
  "name": "Task-Cost-Estimation",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "estimate-task-cost",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 300],
      "id": "task-cost-webhook"
    },
    {
      "parameters": {
        "functionCode": "// Hauptfunktion zur Schätzung der Kosten basierend auf Aufgabenkomplexität\nconst taskRequest = $input.item.json;\n\n// Modell-Datenbank mit Kosten und Funktionen\nconst modelDb = {\n  // Cloud-Modelle\n  \"claude-3-5-sonnet\": {\n    \"type\": \"cloud\",\n    \"provider\": \"anthropic\",\n    \"inputCost\": 3.0,     // € pro 1M Tokens\n    \"outputCost\": 15.0,   // € pro 1M Tokens\n    \"maxContext\": 200000,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 150,  // Tokens pro Sekunde\n    \"complexityHandling\": 9.5,    // 1-10 Skala\n    \"qualityScore\": 9.5,          // 1-10 Skala\n    \"multimodalCapable\": true\n  },\n  \"claude-3-opus\": {\n    \"type\": \"cloud\",\n    \"provider\": \"anthropic\",\n    \"inputCost\": 15.0,\n    \"outputCost\": 75.0,\n    \"maxContext\": 200000,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 100,\n    \"complexityHandling\": 10.0,\n    \"qualityScore\": 10.0,\n    \"multimodalCapable\": true\n  },\n  \"gpt-4o\": {\n    \"type\": \"cloud\",\n    \"provider\": \"openai\",\n    \"inputCost\": 10.0,\n    \"outputCost\": 30.0,\n    \"maxContext\": 128000,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 120,\n    \"complexityHandling\": 9.5,\n    \"qualityScore\": 9.5,\n    \"multimodalCapable\": true\n  },\n  \"gpt-4o-mini\": {\n    \"type\": \"cloud\",\n    \"provider\": \"openai\",\n    \"inputCost\": 5.0,\n    \"outputCost\": 15.0,\n    \"maxContext\": 128000,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 150,\n    \"complexityHandling\": 9.0,\n    \"qualityScore\": 8.8,\n    \"multimodalCapable\": true\n  },\n  \n  // Lokale Modelle\n  \"local-1.5b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 1500,          // Anschaffungskosten in €\n    \"powerConsumptionW\": 150,      // Watt\n    \"maxContext\": 2048,\n    \"maxOutput\": 2048,\n    \"tokenProcessingSpeed\": 100,    // Tokens pro Sekunde\n    \"complexityHandling\": 4.5,      // 1-10 Skala\n    \"qualityScore\": 5.0,            // 1-10 Skala\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 50\n  },\n  \"local-3b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 2000,\n    \"powerConsumptionW\": 200,\n    \"maxContext\": 4096,\n    \"maxOutput\": 2048,\n    \"tokenProcessingSpeed\": 80,\n    \"complexityHandling\": 5.5,\n    \"qualityScore\": 6.0,\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 75\n  },\n  \"local-7b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 2500,\n    \"powerConsumptionW\": 300,\n    \"maxContext\": 8192,\n    \"maxOutput\": 2048,\n    \"tokenProcessingSpeed\": 50,\n    \"complexityHandling\": 7.0,\n    \"qualityScore\": 7.5,\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 100\n  },\n  \"local-13b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 3000,\n    \"powerConsumptionW\": 400,\n    \"maxContext\": 8192,\n    \"maxOutput\": 2048,\n    \"tokenProcessingSpeed\": 30,\n    \"complexityHandling\": 7.5,\n    \"qualityScore\": 8.0,\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 125\n  },\n  \"local-34b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 7500,\n    \"powerConsumptionW\": 800,\n    \"maxContext\": 16384,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 15,\n    \"complexityHandling\": 8.5,\n    \"qualityScore\": 8.8,\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 200\n  },\n  \"local-70b\": {\n    \"type\": \"local\",\n    \"hardwareCost\": 15000,\n    \"powerConsumptionW\": 1200,\n    \"maxContext\": 32768,\n    \"maxOutput\": 4096,\n    \"tokenProcessingSpeed\": 8,\n    \"complexityHandling\": 9.0,\n    \"qualityScore\": 9.2,\n    \"multimodalCapable\": false,\n    \"maintenanceCostPerMonth\": 300\n  }\n};\n\n// Kompexitätskategorien mit typischen Token-Anforderungen\nconst complexityCategories = {\n  \"very_simple\": {\n    description: \"Sehr einfache Aufgaben: Klassifikation, kurze Antworten, einfache Fragen\",\n    avgInputTokens: 200,\n    avgOutputTokens: 100,\n    minComplexityHandling: 4.0,\n    requiredContextSize: 1024,\n    processingTimeMultiplier: 1.0\n  },\n  \"simple\": {\n    description: \"Einfache Aufgaben: Zusammenfassungen, kurze Texte, einfache Faktenrecherche\",\n    avgInputTokens: 1000,\n    avgOutputTokens: 300,\n    minComplexityHandling: 5.0,\n    requiredContextSize: 2048,\n    processingTimeMultiplier: 1.2\n  },\n  \"medium\": {\n    description: \"Mittlere Komplexität: Standard-Codegeneration, detaillierte Antworten, Analysen\",\n    avgInputTokens: 2000,\n    avgOutputTokens: 800,\n    minComplexityHandling: 6.5,\n    requiredContextSize: 4096,\n    processingTimeMultiplier: 1.5\n  },\n  \"complex\": {\n    description: \"Komplexe Aufgaben: Tiefe Textanalysen, fortgeschrittene Codegeneration, logisches Reasoning\",\n    avgInputTokens: 4000,\n    avgOutputTokens: 1500,\n    minComplexityHandling: 7.5,\n    requiredContextSize: 8192,\n    processingTimeMultiplier: 2.0\n  },\n  \"very_complex\": {\n    description: \"Sehr komplexe Aufgaben: Multi-step Reasoning, detaillierte Berichte, komplexe Problemlösung\",\n    avgInputTokens: 8000,\n    avgOutputTokens: 3000,\n    minComplexityHandling: 8.5,\n    requiredContextSize: 16384,\n    processingTimeMultiplier: 3.0\n  },\n  \"extremely_complex\": {\n    description: \"Extrem komplexe Aufgaben: Forschungssynthesen, hochkomplexe Logikketten, AI-Agenten-Systeme\",\n    avgInputTokens: 15000,\n    avgOutputTokens: 4000,\n    minComplexityHandling: 9.5,\n    requiredContextSize: 32768,\n    processingTimeMultiplier: 4.0\n  }\n};\n\n// Parameter aus dem Request extrahieren mit Defaults\nconst {\n  task_complexity = \"medium\",           // very_simple, simple, medium, complex, very_complex, extremely_complex\n  input_tokens,                        // Optional: Explizite Angabe von Eingabe-Tokens\n  output_tokens,                       // Optional: Explizite Angabe von Ausgabe-Tokens\n  context_length,                      // Optional: Explizite Angabe von Kontextlänge\n  models_to_evaluate = Object.keys(modelDb),  // Zu bewertende Modelle\n  require_multimodal = false,          // Multimodale Fähigkeiten erforderlich?\n  quality_threshold = 7.0,             // Mindestqualität (1-10)\n  energy_cost_per_kwh = 0.30,          // Energiekosten pro kWh\n  hardware_amortization_months = 36,   // Abschreibungszeitraum für Hardware in Monaten\n  include_hardware_costs = true,       // Hardware-Kosten einbeziehen?\n  custom_parameters = {}               // Zusätzliche benutzerdefinierte Parameter\n} = taskRequest;\n\n// Funktion zur Berechnung der Tokenisierungskosten für Cloud-Modelle\nfunction calculateCloudModelCost(model, inputTokenCount, outputTokenCount) {\n  const modelInfo = modelDb[model];\n  if (!modelInfo || modelInfo.type !== 'cloud') {\n    throw new Error(`Ungültiges Cloud-Modell: ${model}`);\n  }\n  \n  const inputCost = (inputTokenCount / 1000000) * modelInfo.inputCost;\n  const outputCost = (outputTokenCount / 1000000) * modelInfo.outputCost;\n  \n  // Abgelehnte Anfragen: Wenn der Kontextgröße > maxContext oder erforderliche Qualität > Modellqualität\n  const isRejected = (context_length && context_length > modelInfo.maxContext) || \n                     (quality_threshold && quality_threshold > modelInfo.qualityScore) ||\n                     (require_multimodal && !modelInfo.multimodalCapable);\n  \n  // Verarbeitungszeit in Sekunden\n  const processingTime = isRejected ? 0 : (inputTokenCount + outputTokenCount) / modelInfo.tokenProcessingSpeed;\n  \n  // Antwortlatenz (vereinfacht)\n  const latency = isRejected ? 0 : (processingTime + 1.5); // +1.5s für Netzwerklatenz\n\n  return {\n    inputCost,\n    outputCost,\n    totalCost: inputCost + outputCost,\n    processingTime,\n    latency,\n    isRejected,\n    rejectionReason: isRejected ? getCloudRejectionReason(modelInfo) : null\n  };\n}\n\n// Hilfsfunktion zur Bestimmung des Ablehnungsgrundes\nfunction getCloudRejectionReason(modelInfo) {\n  if (context_length && context_length > modelInfo.maxContext) {\n    return `Kontextgröße (${context_length}) überschreitet maximale Kontextgröße des Modells (${modelInfo.maxContext})`;\n  }\n  if (quality_threshold && quality_threshold > modelInfo.qualityScore) {\n    return `Erforderliche Qualität (${quality_threshold}) überschreitet Modellqualität (${modelInfo.qualityScore})`;\n  }\n  if (require_multimodal && !modelInfo.multimodalCapable) {\n    return \"Modell unterstützt keine multimodalen Aufgaben\";\n  }\n  return \"Unbekannter Grund\";\n}\n\n// Funktion zur Berechnung der Kosten für lokale Modelle\nfunction calculateLocalModelCost(model, inputTokenCount, outputTokenCount) {\n  const modelInfo = modelDb[model];\n  if (!modelInfo || modelInfo.type !== 'local') {\n    throw new Error(`Ungültiges lokales Modell: ${model}`);\n  }\n  \n  // Prüfen, ob das Modell die Anforderungen erfüllt\n  const isRejected = (context_length && context_length > modelInfo.maxContext) || \n                     (quality_threshold && quality_threshold > modelInfo.qualityScore) ||\n                     (require_multimodal && !modelInfo.multimodalCapable);\n  \n  if (isRejected) {\n    return {\n      energyCost: 0,\n      hardwareCost: 0,\n      maintenanceCost: 0,\n      totalCost: 0,\n      processingTime: 0,\n      latency: 0,\n      isRejected: true,\n      rejectionReason: getLocalRejectionReason(modelInfo)\n    };\n  }\n  \n  // Gesamte Tokenanzahl\n  const totalTokens = inputTokenCount + outputTokenCount;\n  \n  // Verarbeitungszeit unter Berücksichtigung der Aufgabenkomplexität\n  const complexityInfo = complexityCategories[task_complexity];\n  const adjustedProcessingTime = totalTokens / modelInfo.tokenProcessingSpeed * \n                                 complexityInfo.processingTimeMultiplier;\n  \n  // Energie- und Hardwarekosten\n  // Energieverbrauch in kWh\n  const energyConsumption = (modelInfo.powerConsumptionW / 1000) * (adjustedProcessingTime / 3600);\n  const energyCost = energyConsumption * energy_cost_per_kwh;\n  \n  // Hardware-Abschreibungskosten\n  let hardwareCost = 0;\n  if (include_hardware_costs) {\n    // Stündliche Hardware-Kosten basierend auf Abschreibungszeitraum\n    const hourlyHardwareCost = modelInfo.hardwareCost / (hardware_amortization_months * 30 * 24);\n    hardwareCost = hourlyHardwareCost * (adjustedProcessingTime / 3600);\n  }\n  \n  // Wartungskosten\n  const hourlyMaintenanceCost = modelInfo.maintenanceCostPerMonth / (30 * 24);\n  const maintenanceCost = hourlyMaintenanceCost * (adjustedProcessingTime / 3600);\n  \n  // Gesamtkosten\n  const totalCost = energyCost + hardwareCost + maintenanceCost;\n  \n  // Latenz ist bei lokalen Modellen gleich der Verarbeitungszeit\n  const latency = adjustedProcessingTime;\n  \n  return {\n    energyCost,\n    hardwareCost,\n    maintenanceCost,\n    totalCost,\n    energyConsumption,\n    processingTime: adjustedProcessingTime,\n    latency,\n    isRejected: false\n  };\n}\n\n// Hilfsfunktion zur Bestimmung des Ablehnungsgrundes für lokale Modelle\nfunction getLocalRejectionReason(modelInfo) {\n  if (context_length && context_length > modelInfo.maxContext) {\n    return `Kontextgröße (${context_length}) überschreitet maximale Kontextgröße des Modells (${modelInfo.maxContext})`;\n  }\n  if (quality_threshold && quality_threshold > modelInfo.qualityScore) {\n    return `Erforderliche Qualität (${quality_threshold}) überschreitet Modellqualität (${modelInfo.qualityScore})`;\n  }\n  if (require_multimodal && !modelInfo.multimodalCapable) {\n    return \"Modell unterstützt keine multimodalen Aufgaben\";\n  }\n  return \"Unbekannter Grund\";\n}\n\n// Hauptfunktion zur Berechnung der Kosten für verschiedene Modelle\nfunction estimateTaskCosts() {\n  // Bestimme die Tokens basierend auf Komplexität oder expliziten Angaben\n  let inputTokenCount, outputTokenCount, requiredContext;\n  \n  if (input_tokens && output_tokens) {\n    // Verwende explizit angegebene Token-Zahlen\n    inputTokenCount = input_tokens;\n    outputTokenCount = output_tokens;\n  } else {\n    // Verwende die durchschnittlichen Token-Zahlen basierend auf der Komplexitätskategorie\n    const complexityInfo = complexityCategories[task_complexity];\n    if (!complexityInfo) {\n      throw new Error(`Ungültige Komplexitätskategorie: ${task_complexity}`);\n    }\n    \n    inputTokenCount = complexityInfo.avgInputTokens;\n    outputTokenCount = complexityInfo.avgOutputTokens;\n    requiredContext = complexityInfo.requiredContextSize;\n  }\n  \n  // Verwende explizite Kontextlänge, falls angegeben, sonst die aus der Komplexitätskategorie\n  const effectiveContextLength = context_length || requiredContext;\n  \n  // Ergebnisse für jedes Modell berechnen\n  const results = {};\n  for (const model of models_to_evaluate) {\n    try {\n      const modelInfo = modelDb[model];\n      if (!modelInfo) {\n        results[model] = { error: `Unbekanntes Modell: ${model}` };\n        continue;\n      }\n      \n      // Prüfe, ob das Modell die grundlegenden Anforderungen erfüllt\n      const complexityInfo = complexityCategories[task_complexity];\n      if (modelInfo.complexityHandling < complexityInfo.minComplexityHandling) {\n        results[model] = { \n          isRejected: true, \n          rejectionReason: `Modell kann die erforderliche Komplexität nicht bewältigen (${task_complexity})`\n        };\n        continue;\n      }\n      \n      // Berechne die spezifischen Kosten je nach Modelltyp\n      if (modelInfo.type === 'cloud') {\n        results[model] = calculateCloudModelCost(model, inputTokenCount, outputTokenCount);\n      } else {\n        results[model] = calculateLocalModelCost(model, inputTokenCount, outputTokenCount);\n      }\n      \n      // Füge weitere Modellinfos hinzu\n      results[model].modelType = modelInfo.type;\n      results[model].provider = modelInfo.provider || 'local';\n      results[model].qualityScore = modelInfo.qualityScore;\n      results[model].maxContext = modelInfo.maxContext;\n      results[model].multimodalCapable = modelInfo.multimodalCapable;\n    } catch (error) {\n      results[model] = { error: error.message };\n    }\n  }\n  \n  // Finde das kostengünstigste geeignete Modell\n  let cheapestModel = null;\n  let lowestCost = Infinity;\n  \n  for (const model in results) {\n    if (!results[model].isRejected && !results[model].error && results[model].totalCost < lowestCost) {\n      cheapestModel = model;\n      lowestCost = results[model].totalCost;\n    }\n  }\n  \n  // Finde das schnellste geeignete Modell\n  let fastestModel = null;\n  let lowestLatency = Infinity;\n  \n  for (const model in results) {\n    if (!results[model].isRejected && !results[model].error && results[model].latency < lowestLatency) {\n      fastestModel = model;\n      lowestLatency = results[model].latency;\n    }\n  }\n  \n  // Finde das qualitativ beste Modell\n  let bestQualityModel = null;\n  let highestQuality = -Infinity;\n  \n  for (const model in results) {\n    const quality = results[model].qualityScore;\n    if (!results[model].isRejected && !results[model].error && quality > highestQuality) {\n      bestQualityModel = model;\n      highestQuality = quality;\n    }\n  }\n  \n  // Berechne die Gesamtkosten bei Verwendung des Cloud-Modells als Referenz\n  let cloudReferenceModel = \"claude-3-5-sonnet\"; // Standardreferenz\n  const cloudCost = results[cloudReferenceModel] && !results[cloudReferenceModel].isRejected ? \n                   results[cloudReferenceModel].totalCost : \n                   null;\n  \n  // Rückgabe der Ergebnisse\n  return {\n    task: {\n      complexity: task_complexity,\n      complexity_description: complexityCategories[task_complexity].description,\n      input_tokens: inputTokenCount,\n      output_tokens: outputTokenCount,\n      total_tokens: inputTokenCount + outputTokenCount,\n      context_length: effectiveContextLength,\n      multimodal_required: require_multimodal,\n      quality_threshold: quality_threshold\n    },\n    model_results: results,\n    recommendations: {\n      most_cost_effective: cheapestModel ? {\n        model: cheapestModel,\n        cost: results[cheapestModel].totalCost,\n        savings_vs_cloud: cloudCost ? (cloudCost - results[cheapestModel].totalCost) : null,\n        savings_percentage: cloudCost ? ((cloudCost - results[cheapestModel].totalCost) / cloudCost * 100) : null\n      } : null,\n      fastest_response: fastestModel ? {\n        model: fastestModel,\n        latency: results[fastestModel].latency\n      } : null,\n      highest_quality: bestQualityModel ? {\n        model: bestQualityModel,\n        quality_score: results[bestQualityModel].qualityScore\n      } : null\n    },\n    meta: {\n      timestamp: new Date().toISOString(),\n      energy_cost_per_kwh: energy_cost_per_kwh,\n      hardware_amortization_months: hardware_amortization_months,\n      include_hardware_costs: include_hardware_costs\n    }\n  };\n}\n\n// Führe die Kostenschätzung aus\ntry {\n  const estimate = estimateTaskCosts();\n  return estimate;\n} catch (error) {\n  return {\n    error: error.message,\n    timestamp: new Date().toISOString()\n  };\n}"
      },
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [440, 300],
      "id": "calculate-task-costs"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "batch-estimate",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 500],
      "id": "batch-estimate-webhook"
    },
    {
      "parameters": {
        "functionCode": "// Batch-Verarbeitung für mehrere Aufgaben\nconst batchRequest = $input.item.json;\nconst { tasks = [], common_parameters = {} } = batchRequest;\n\n// Importiere die Hauptberechnungsfunktion (als Referenz - in n8n müsste dieser Code dupliziert werden)
const calculateTaskCosts = $node[\"calculate-task-costs\"].function;\n\n// Analysiere den Workflow und berechne die Kosten für jeden Schritt\nfunction estimateWorkflowCosts() {\n  // Validiere die Workflow-Struktur\n  if (!workflow_steps || !Array.isArray(workflow_steps) || workflow_steps.length === 0) {\n    throw new Error(\"Workflow-Struktur ist ungültig oder leer\");\n  }\n  \n  // Topologische Sortierung, um die Workflow-Schritte in Ausführungsreihenfolge zu bringen\n  const sortedSteps = topologicalSort(workflow_steps);\n  \n  // Verarbeite jeden Schritt und berechne die Kosten\n  const stepResults = [];\n  const modelUsageCounts = {};\n  \n  for (const step of sortedSteps) {\n    // Kombiniere step-spezifische Parameter mit gemeinsamen Parametern\n    const stepParameters = { ...common_parameters, ...step.parameters };\n    \n    try {\n      // Führe die Kostenschätzung für diesen Schritt aus\n      const result = calculateTaskCosts(stepParameters);\n      \n      // Wähle das beste Modell basierend auf dem Optimierungsziel\n      let selectedModel, selectedCost, selectedLatency, selectedQuality;\n      \n      if (cost_optimization && result.recommendations.most_cost_effective) {\n        // Kostenoptimierung: Wähle das kostengünstigste Modell\n        selectedModel = result.recommendations.most_cost_effective.model;\n        selectedCost = result.recommendations.most_cost_effective.cost;\n        \n        // Extrahiere Latenz und Qualität des gewählten Modells\n        selectedLatency = result.model_results[selectedModel].latency;\n        selectedQuality = result.model_results[selectedModel].qualityScore;\n      } else if (result.recommendations.fastest_response) {\n        // Geschwindigkeitsoptimierung: Wähle das schnellste Modell\n        selectedModel = result.recommendations.fastest_response.model;\n        selectedLatency = result.model_results[selectedModel].latency;\n        \n        // Extrahiere Kosten und Qualität des gewählten Modells\n        selectedCost = result.model_results[selectedModel].totalCost;\n        selectedQuality = result.model_results[selectedModel].qualityScore;\n      } else if (result.recommendations.highest_quality) {\n        // Qualitätsoptimierung: Wähle das qualitativ beste Modell\n        selectedModel = result.recommendations.highest_quality.model;\n        selectedQuality = result.recommendations.highest_quality.quality_score;\n        \n        // Extrahiere Kosten und Latenz des gewählten Modells\n        selectedCost = result.model_results[selectedModel].totalCost;\n        selectedLatency = result.model_results[selectedModel].latency;\n      } else {\n        throw new Error(\"Keine geeigneten Modelle für diesen Workflow-Schritt gefunden\");\n      }\n      \n      // Zähle die Modellnutzung\n      modelUsageCounts[selectedModel] = (modelUsageCounts[selectedModel] || 0) + 1;\n      \n      // Speichere das Ergebnis für diesen Schritt\n      stepResults.push({\n        step_id: step.id,\n        step_name: step.name || `Schritt ${stepResults.length + 1}`,\n        description: step.description || \"\",\n        complexity: step.parameters?.task_complexity || common_parameters.task_complexity || \"medium\",\n        selected_model: selectedModel,\n        cost: selectedCost,\n        latency: selectedLatency,\n        quality: selectedQuality,\n        token_counts: {\n          input: result.task.input_tokens,\n          output: result.task.output_tokens,\n          total: result.task.total_tokens\n        },\n        full_result: result\n      });\n    } catch (error) {\n      stepResults.push({\n        step_id: step.id,\n        step_name: step.name || `Schritt ${stepResults.length + 1}`,\n        description: step.description || \"\",\n        complexity: step.parameters?.task_complexity || common_parameters.task_complexity || \"medium\",\n        error: error.message\n      });\n    }\n  }\n  \n  // Berechne die kritischen Pfade und die Gesamtkosten\n  const criticalPath = calculateCriticalPath(workflow_steps, stepResults);\n  const totalWorkflowCost = stepResults.reduce((sum, step) => sum + (step.cost || 0), 0);\n  const totalWorkflowTime = criticalPath.totalTime;\n  \n  // Berechne die Kosten für verschiedene Zeiträume\n  const projectedCosts = projectCostsOverTime(\n    totalWorkflowCost, \n    daily_executions, \n    monthly_growth_rate, \n    projection_months\n  );\n  \n  // Rückgabe der Workflow-Ergebnisse mit Zusammenfassung\n  return {\n    workflow_results: {\n      steps: stepResults,\n      critical_path: criticalPath.path,\n      execution_time: totalWorkflowTime,\n      cost_per_execution: totalWorkflowCost\n    },\n    model_usage: Object.entries(modelUsageCounts).map(([model, count]) => ({\n      model,\n      step_count: count,\n      percentage: (count / stepResults.length) * 100\n    })),\n    cost_projections: projectedCosts,\n    summary: {\n      total_steps: stepResults.length,\n      successful_estimates: stepResults.filter(r => !r.error).length,\n      failed_estimates: stepResults.filter(r => r.error).length,\n      cost_per_execution: totalWorkflowCost,\n      daily_cost: totalWorkflowCost * daily_executions,\n      monthly_cost: totalWorkflowCost * daily_executions * 30,\n      annual_cost: totalWorkflowCost * daily_executions * 365,\n      projected_annual_cost_with_growth: projectedCosts.annual,\n      execution_time_seconds: totalWorkflowTime\n    },\n    optimization_strategy: cost_optimization ? \"cost\" : \"performance\",\n    timestamp: new Date().toISOString()\n  };\n}\n\n// Topologische Sortierung der Workflow-Schritte\nfunction topologicalSort(steps) {\n  // Erstelle eine Kopie der Schritte, um die Originaldaten nicht zu verändern\n  const nodesCopy = JSON.parse(JSON.stringify(steps));\n  \n  // Erstelle die Abhängigkeitsgraphen\n  const graph = {};\n  const inDegree = {};\n  \n  // Initialisiere Graphen\n  for (const node of nodesCopy) {\n    graph[node.id] = [];\n    inDegree[node.id] = 0;\n  }\n  \n  // Fülle die Graphen mit Abhängigkeiten\n  for (const node of nodesCopy) {\n    if (node.dependencies && Array.isArray(node.dependencies)) {\n      for (const depId of node.dependencies) {\n        if (graph[depId]) {\n          graph[depId].push(node.id);\n          inDegree[node.id] = (inDegree[node.id] || 0) + 1;\n        }\n      }\n    }\n  }\n  \n  // Kahn's Algorithmus für topologische Sortierung\n  const queue = [];\n  for (const nodeId in inDegree) {\n    if (inDegree[nodeId] === 0) {\n      queue.push(nodeId);\n    }\n  }\n  \n  const result = [];\n  while (queue.length > 0) {\n    const nodeId = queue.shift();\n    const node = nodesCopy.find(n => n.id === nodeId);\n    if (node) {\n      result.push(node);\n    }\n    \n    for (const neighbor of graph[nodeId]) {\n      inDegree[neighbor]--;\n      if (inDegree[neighbor] === 0) {\n        queue.push(neighbor);\n      }\n    }\n  }\n  \n  // Prüfe auf Zyklen im Graphen\n  if (result.length !== nodesCopy.length) {\n    throw new Error(\"Der Workflow enthält Zyklen und kann nicht sortiert werden\");\n  }\n  \n  return result;\n}\n\n// Berechnung des kritischen Pfades im Workflow\nfunction calculateCriticalPath(steps, results) {\n  // Erstelle eine Map der Schrittergebnisse nach ID\n  const resultMap = {};\n  for (const result of results) {\n    if (!result.error) {\n      resultMap[result.step_id] = result;\n    }\n  }\n  \n  // Erstelle den Abhängigkeitsgraphen\n  const graph = {};\n  for (const step of steps) {\n    graph[step.id] = step.dependencies || [];\n  }\n  \n  // Berechne den frühesten Start- und Endzeitpunkt für jeden Schritt\n  const earliestStart = {};\n  const earliestFinish = {};\n  \n  // Initialisiere alle Schritte mit einem frühesten Start von 0\n  for (const step of steps) {\n    earliestStart[step.id] = 0;\n    earliestFinish[step.id] = 0;\n  }\n  \n  // Topologisch sortierte Schritte verwenden, um Vorwärtsdurchlauf zu machen\n  const sortedSteps = topologicalSort(steps);\n  \n  for (const step of sortedSteps) {\n    if (step.dependencies && step.dependencies.length > 0) {\n      // Finde den spätesten Endzeitpunkt aller Vorgänger\n      let maxPredecessorFinish = 0;\n      for (const predId of step.dependencies) {\n        if (earliestFinish[predId] > maxPredecessorFinish) {\n          maxPredecessorFinish = earliestFinish[predId];\n        }\n      }\n      earliestStart[step.id] = maxPredecessorFinish;\n    }\n    \n    // Berechne den frühesten Endzeitpunkt basierend auf der Verarbeitungszeit\n    if (resultMap[step.id]) {\n      earliestFinish[step.id] = earliestStart[step.id] + (resultMap[step.id].latency || 0);\n    } else {\n      // Fallback für Schritte ohne Ergebnis\n      earliestFinish[step.id] = earliestStart[step.id];\n    }\n  }\n  \n  // Finde den spätesten Endzeitpunkt (Projektende)\n  let projectEnd = 0;\n  for (const stepId in earliestFinish) {\n    if (earliestFinish[stepId] > projectEnd) {\n      projectEnd = earliestFinish[stepId];\n    }\n  }\n  \n  // Berechne den spätesten Start- und Endzeitpunkt für jeden Schritt\n  const latestStart = {};\n  const latestFinish = {};\n  \n  // Initialisiere alle Schritte mit einem spätesten Ende von Projektende\n  for (const step of steps) {\n    latestFinish[step.id] = projectEnd;\n    latestStart[step.id] = projectEnd;\n  }\n  \n  // Rückwärtsdurchlauf durch den Graphen\n  for (const step of sortedSteps.slice().reverse()) {\n    if (graph[step.id].length > 0) {\n      // Finde den frühesten Startzeitpunkt aller Nachfolger\n      let minSuccessorStart = projectEnd;\n      for (const succId of graph[step.id]) {\n        if (latestStart[succId] < minSuccessorStart) {\n          minSuccessorStart = latestStart[succId];\n        }\n      }\n      latestFinish[step.id] = minSuccessorStart;\n    } else {\n      // Für Schritte ohne Nachfolger ist der späteste Endzeitpunkt gleich dem Projektende\n      latestFinish[step.id] = projectEnd;\n    }\n    \n    // Berechne den spätesten Startzeitpunkt basierend auf der Verarbeitungszeit\n    if (resultMap[step.id]) {\n      latestStart[step.id] = latestFinish[step.id] - (resultMap[step.id].latency || 0);\n    } else {\n      // Fallback für Schritte ohne Ergebnis\n      latestStart[step.id] = latestFinish[step.id];\n    }\n  }\n  \n  // Berechne den Puffer für jeden Schritt und identifiziere kritische Schritte\n  const slack = {};\n  const criticalSteps = [];\n  \n  for (const step of steps) {\n    slack[step.id] = latestStart[step.id] - earliestStart[step.id];\n    if (slack[step.id] === 0) {\n      criticalSteps.push(step.id);\n    }\n  }\n  \n  // Erstelle den kritischen Pfad\n  const criticalPath = [];\n  for (const stepId of criticalSteps) {\n    const step = steps.find(s => s.id === stepId);\n    if (step && resultMap[stepId]) {\n      criticalPath.push({\n        step_id: stepId,\n        step_name: step.name || stepId,\n        start_time: earliestStart[stepId],\n        end_time: earliestFinish[stepId],\n        duration: resultMap[stepId].latency || 0\n      });\n    }\n  }\n  \n  // Sortiere den kritischen Pfad nach Startzeit\n  criticalPath.sort((a, b) => a.start_time - b.start_time);\n  \n  return {\n    path: criticalPath,\n    totalTime: projectEnd\n  };\n}\n\n// Projektion der Kosten über die Zeit\nfunction projectCostsOverTime(baseCost, dailyExecutions, monthlyGrowthRate, months) {\n  const projections = {\n    monthly: [],\n    quarterly: [],\n    annual: 0\n  };\n  \n  let currentDailyExecutions = dailyExecutions;\n  let totalAnnualCost = 0;\n  \n  for (let month = 1; month <= months; month++) {\n    // Berechne die monatlichen Kosten\n    const monthlyCost = baseCost * currentDailyExecutions * 30;\n    \n    // Füge zur monatlichen Projektion hinzu\n    projections.monthly.push({\n      month,\n      executions_per_day: currentDailyExecutions,\n      cost: monthlyCost\n    });\n    \n    // Füge zur vierteljährlichen Projektion hinzu, falls ein Quartal abgeschlossen ist\n    if (month % 3 === 0) {\n      const quarterlyData = {\n        quarter: Math.floor(month / 3),\n        months: [(month - 2), (month - 1), month],\n        cost: projections.monthly.slice(-3).reduce((sum, m) => sum + m.cost, 0)\n      };\n      projections.quarterly.push(quarterlyData);\n    }\n    \n    // Summiere die jährlichen Kosten\n    totalAnnualCost += monthlyCost;\n    \n    // Aktualisiere die täglichen Ausführungen basierend auf der Wachstumsrate\n    currentDailyExecutions *= (1 + (monthlyGrowthRate / 100));\n  }\n  \n  // Speichere die Gesamtjahreskosten\n  projections.annual = totalAnnualCost;\n  \n  return projections;\n}\n\n// Führe die Workflow-Kostenschätzung aus\ntry {\n  const workflowEstimate = estimateWorkflowCosts();\n  return workflowEstimate;\n} catch (error) {\n  return {\n    error: error.message,\n    timestamp: new Date().toISOString()\n  };\n}"
      },
echnungsfunktion (als Referenz - in n8n müsste dieser Code dupliziert werden)\nconst calculateTaskCosts = $node[\"calculate-task-costs\"].function;\n\n// Verarbeite jede Aufgabe in der Gruppe\nconst batchResults = [];\n\nfor (const task of tasks) {\n  // Kombiniere aufgabenspezifische Parameter mit gemeinsamen Parametern\n  const combinedParameters = { ...common_parameters, ...task };\n  \n  try {\n    // Führe die Kostenschätzung für diese Aufgabe aus\n    const result = calculateTaskCosts(combinedParameters);\n    batchResults.push({\n      task_id: task.task_id || `Task-${batchResults.length + 1}`,\n      task_description: task.description || `Aufgabe ${batchResults.length + 1}`,\n      complexity: task.task_complexity || common_parameters.task_complexity || \"medium\",\n      result: result\n    });\n  } catch (error) {\n    batchResults.push({\n      task_id: task.task_id || `Task-${batchResults.length + 1}`,\n      task_description: task.description || `Aufgabe ${batchResults.length + 1}`,\n      complexity: task.task_complexity || common_parameters.task_complexity || \"medium\",\n      error: error.message\n    });\n  }\n}\n\n// Berechne die Gesamtkosten\nlet totalCloudCost = 0;\nlet totalLocalCost = 0;\nlet totalSavings = 0;\n\nfor (const result of batchResults) {\n  if (result.result && result.result.recommendations && result.result.recommendations.most_cost_effective) {\n    const recommendation = result.result.recommendations.most_cost_effective;\n    \n    // Kostengünstigstes Modell\n    const bestModelCost = recommendation.cost || 0;\n    \n    // Cloud-Referenzkosten\n    const cloudCost = recommendation.savings_vs_cloud !== null ? \n                      bestModelCost + recommendation.savings_vs_cloud : \n                      bestModelCost; // Fallback, falls keine Ersparnisse berechnet wurden\n    \n    // Summieren\n    if (result.result.model_results[recommendation.model].modelType === 'cloud') {\n      totalCloudCost += bestModelCost;\n    } else {\n      totalLocalCost += bestModelCost;\n    }\n    \n    // Ersparnisse\n    totalSavings += (recommendation.savings_vs_cloud || 0);\n  }\n}\n\n// Rückgabe der Batch-Ergebnisse mit Zusammenfassung\nreturn {\n  batch_results: batchResults,\n  summary: {\n    total_tasks: batchResults.length,\n    successful_estimates: batchResults.filter(r => !r.error).length,\n    failed_estimates: batchResults.filter(r => r.error).length,\n    total_cloud_cost: totalCloudCost,\n    total_local_cost: totalLocalCost,\n    total_cost: totalCloudCost + totalLocalCost,\n    total_savings_vs_all_cloud: totalSavings,\n    savings_percentage: totalSavings > 0 ? (totalSavings / (totalCloudCost + totalLocalCost + totalSavings) * 100) : 0\n  },\n  timestamp: new Date().toISOString()\n};"
      },
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [440, 500],
      "id": "process-batch-estimates"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "workflow-cost-estimate",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 700],
      "id": "workflow-cost-webhook"
    },
    {
      "parameters": {
        "functionCode": "// Workflow-Kosten-Schätzung für komplette Prozess-Workflows\nconst workflowRequest = $input.item.json;\n\n// Extrahiere Parameter mit Defaults\nconst {\n  workflow_steps = [],           // Array von Workflow-Schritten mit Abhängigkeiten\n  common_parameters = {},       // Gemeinsame Parameter für alle Schritte\n  daily_executions = 1,         // Tägliche Ausführungen\n  monthly_growth_rate = 0,      // Monatliche Wachstumsrate in Prozent\n  projection_months = 12,       // Anzahl der Monate für die Projektion\n  cost_optimization = true      // Ob Kosten optimiert werden sollen\n} = workflowRequest;\n\n// Importiere die Hauptber
